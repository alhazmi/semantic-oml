'\" t
.\"     Title: liboml2
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.76.1 <http://docbook.sf.net/>
.\"      Date: 2015-04-16
.\"    Manual: The OML Manual
.\"    Source: OML 2.12.0pre.79-58cf-dirty
.\"  Language: English
.\"
.TH "LIBOML2" "3" "2015\-04\-16" "OML 2\&.12\&.0pre\&.79\-58cf\-" "The OML Manual"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
liboml2 \- OML2 client library
.SH "SYNOPSIS"
.sp
.nf
\fB#include <oml2/omlc\&.h>\fR
.fi
.sp
.nf
\fIint\fR    \fBomlc_init\fR(\fIconst char\fR *appname, \fIint\fR *pargc, \fIconst char\fR *argv[], \fIo_log_fn\fR log_fn);
\fIOmlMP\fR* \fBomlc_add_mp\fR(\fIconst char\fR *name, \fIOmlMPDef\fR *definition);
\fIint\fR    \fBomlc_start\fR(\fIvoid\fR);
\fIvoid\fR   \fBomlc_inject\fR(\fIOmlMP\fR *mp, OmlValueU *values);
\fIint\fR    \fBomlc_inject_metadata\fR(\fIOmlMP\fR* mp, \fIconst char\fR* key, \fIconst OmlValueU\fR* value, \fIOmlValueT\fR type, \fIconst char\fR* fname);
\fIoml_guid_t\fR \fBomlc_guid_generate\fR();
\fIint\fR    \fBomlc_close\fR(\fIvoid\fR);
.fi
.sp
.nf
\fB#define OML_FROM_MAIN\fR \fI// enable oml_register_mps() and necessary storage; only in one file\fR
\fB#include "APPNAME_oml\&.h"\fR
.fi
.sp
.nf
\fIinline void\fR \fBoml_register_mps\fR();
\fIinline void\fR \fBoml_inject_MPNAME\fR(\fIOmlMP\fR* mp, \&...);
.fi
.SH "DESCRIPTION"
.sp
\fBliboml2\fR is the client library for OML2\&. It provides an API for application writers to collect measurements from their applications via user\-defined \fIMeasurement Points\fR (MPs)\&. It also provides a flexible filtering and collection mechanism that allows application users to customise how measurements are processed and stored by an OML\-enabled application\&.
.sp
This man page summarises the API\&. Each function in the API also has its own detailed man page\&. To learn how to configure an application that uses the API from the command line, see \fBliboml2\fR(1)\&. To learn about the external configuration file that \fBliboml2\fR can use, see \fBliboml2.conf\fR(5)\&.
.sp
A programmer who wants to use \fBliboml2\fR to perform measurements in their application must first decide what to measure\&. OML lets the programmer first define \fIMPs\fR and then inject measurement tuples into them\&. The core of the library then performs filtering on the injected measurements and, at predefined times, emits the filtered samples to either a local file or a measurement server (see \fBoml2-server\fR(1))\&.
.sp
A program using OML can therefore be divided into two stages:
.PP
Initialisation
.RS 4
First the library is initialised and measurement points are defined\&.
.RE
.PP
Measurement
.RS 4
Second, the filters are constructed and enabled by calling
\fBomlc_start\fR(3)\&. Measurement can proceed, with as many calls to
\fBomlc_inject\fR(3)
as required\&.
.RE
.sp
In some cases, it is necessary to occasionaly inject metadata about one \fIMP\fR, or one of its fields (e\&.g\&., unit or quality index of the current samples)\&. The \fBomlc_inject_metadata\fR(3) function can be used for this purpose\&.
.sp
It is also sometimes necessary to link measurement tuples together (e\&.g\&., the destination IP of a packet in a network \fIMP\fR and its transport protocol and port in a transport \fIMP\fR)\&. OML supports the concept of a Globally Unique ID (GUID) as a data type\&. It is a random identifier which can be generated on demand using the \fBomlc_guid_generate\fR() function\&. It returns an \fIoml_guid_t\fR, which can then be injected into any \fIMP\fR with a field of type \fI:guid\fR (see \fBoml2-scaffold\fR(1))\&. In case a GUID is not required for the injection of a specific tuple (i\&.e\&., no linkage to other measurements), the special value \fIOMLC_GUID_NULL\fR can be used\&.
.sp
For convenience, it is recommended to use \fBoml2-scaffold\fR(1) to generate helper functions for MP registration and injection (\fBoml_register_mps\fR and \fBoml_inject_MPNAME\fR) which take care of preparing the data and passing it to \fBomlc_add_mp\fR(3) and \fBomlc_inject\fR(3), respectively\&.
.sp
It is also best to call \fBomlc_close\fR(3) to shut down the measurement library cleanly once measurement tasks are completed, such as when the application is terminating\&.
.SS "Initialisation"
.sp
When the application starts up, the programmer should make a call to \fBomlc_init\fR(3) to initialise \fBliboml2\fR\&. The function accepts a name for the application itself, together with the executable\(cqs command line arguments (the C \fBmain\fR() function\(cqs \fBargc\fR and \fBargv\fR parameters), and a fourth argument which is not widely used and can safely be set to NULL:
.sp
.if n \{\
.RS 4
.\}
.nf
#include <oml2/omlc\&.h>

int main(int argc, const char **argv)
{
  int result = omlc_init ("MyOmlClient", &argc, argv, NULL);
  if (result == \-1) {
    fprintf (stderr, "Could not initialise OML\en");
    exit (1);
  } else if (result == 1) {
    fprintf (stderr, "OML was disabled by the user, exiting\en");
    exit (0);
  }

  /* Do application stuff\&.\&.\&. */

  return 0;
}
.fi
.if n \{\
.RE
.\}
.sp
The \fBomlc_init\fR(3) function gathers configuration information from the command line arguments, the environment, and possibly an external configuration file, and sets internal configuration options of the library\&. It removes any command line options that it recognises, so that the application itself does not get confused when it tries to interpret the command line\&. All OML options start with the prefix \fB\-\-oml\-\fR\&. An application should call \fBomlc_init\fR(3) \fIbefore\fR running its own command line option parser\&.
.sp
After initialising the library, the programmer must define the application\(cqs \fIMPs\fR\&. Each \fIMP\fR is defined as a typed tuple\&. OML supports basic integer types, a double\-precision floating point type, a string type and a blob type\&.
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBUsing the registration helper\fR
.RS 4
.sp
This is the recommended method as it is easiest\&.
.sp
The \fBoml2-scaffold\fR(1) tool can generate the definition of the desired measurement points, and a single registration function as part of the OML header (\fIAPPNAME_oml\&.h\fR generated with the \fB\-\-oml\fR flag)\&. The registration function, \fBoml_register_mps\fR(), declares theses MPs to the library\&. It takes no argument, and initialises a structure \fBg_oml_mps_APPNAME\fR which contains named pointer to each measurement point\&. Taking the example from \fBoml2-scaffold\fR(1),
.sp
.if n \{\
.RS 4
.\}
.nf
defApplication(\*(Aqoml:man:foo\*(Aq, \*(Aqfoo\*(Aq) do |app|
  # \&.\&.\&. Some needed code skipped here \&.\&.\&.
  app\&.defMeasurement("memory") do |mp|
    # \&.\&.\&. Some more code skipped here \&.\&.\&.
  end

  app\&.defMeasurement("cpu") do |mp|
    # \&.\&.\&. Some more code skipped here \&.\&.\&.
  end
end
.fi
.if n \{\
.RE
.\}
.sp
The \fBoml_register_mps\fR() function declares and initialises a structure containing pointers to the \fIOmlMP*\fR\&. In this example, where the application name is \fIfoo\fR, it will be accessible as \fIg_oml_mps_foo\fR, and the \fIOmlMP*\fR for \fImemory\fR and \fIcpu\fR as \fIg_oml_mps_foo→memory\fR and \fIg_oml_mps_foo→cpu\fR, respectively\&.
.sp
This function is made available conditionally from \fIAPPNAME_oml\&.h\fR\&. Indeed, it requires objects which need only be allocated once, and is done at the same time\&. To make this function available, one must \fI#define\fR \fBcpp\fR(1) macro \fIOML_FROM_MAIN\fR prior to the \fI#include\fR statement for \fIAPPNAME_oml\&.h\fR\&. This should be done \fBonly in file using oml_register_mps()\fR\&.
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBRegistering MPs manually\fR
.RS 4
.sp
In case some or more \fIMPs\fR cannot be known at compile time (e\&.g\&., a plugin providing its own \fIMPs\fR), the auto\-generated registration code cannot be used\&. These \fIMPs\fR have to be defined and added manually in the code\&. An \fIMP\fR definition is represented as an array of \fIOmlMPDef\fR objects, terminated by a NULL object, as shown here:
.sp
.if n \{\
.RS 4
.\}
.nf
OmlMPDef mp_def [] =
{
  { "source", OML_UINT32_VALUE },
  { "destination", OML_UINT32_VALUE },
  { "length", OML_UINT32_VALUE },
  { "weight", OML_DOUBLE_VALUE },
  { "protocol", OML_STRING_VALUE },
  { NULL, (OmlValueT)0 }
};
.fi
.if n \{\
.RE
.\}
.sp
The first member of the \fIOmlMPDef\fR struct is the name of the field of the \fIMP\fR that it represents\&. The second member is its type\&. The name appears in the schema for the local file storage, and as part of the database column name for the database created by \fBoml2-server\fR(1)\&.
.sp
To register the \fIMP\fR definition with \fBliboml2\fR, the programmer must call \fBomlc_add_mp\fR(3):
.sp
.if n \{\
.RS 4
.\}
.nf
OmlMP* mp = omlc_add_mp ("packet_info", mp_def);

if (mp == NULL) {
 fprintf (stderr, "Error: could not register Measurement Point \*(Aqpacket_info\*(Aq");
 exit (1);
}
.fi
.if n \{\
.RE
.\}
.sp
This function returns a handle to the internal \fIMP\fR object, which should be used in subsequent calls to \fBomlc_inject\fR(3), and should be treated as opaque\&.
.RE
.SS "Measurement"
.sp
Once all measurement points have been defined and created using calls to \fBomlc_add_mp\fR(3), the programmer must start the measurement collection process by calling \fBomlc_start\fR(3)\&. This call creates the internal filters according to the current configuration options, and starts the filter output sampling threads for \*(Aqinterval\*(Aq style filters (for more information see \fBliboml2.conf\fR(5))\&. Once \fBomlc_start\fR(3) has been called, no more \fIMPs\fR can be added: further calls to \fBomlc_add_mp\fR(3) will be ignored\&. Conversely, once \fBomlc_start\fR(3) has been called, calls can be made to perform measurements, and inject there results into the OML reporting path\&.
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBUsing injection helpers\fR
.RS 4
.sp
This is the recommended method as it is easiest and much less error\-prone\&. It is also more future\-proof as it shields the application from low\-level API changes\&. These helpers also provide C\-compiler type\-checking and proper memory management\&.
.sp
The \fBoml2-scaffold\fR(1) tool can generate helper injection functions as part of the OML header (\fB\-\-oml\fR)\&. Their prototype is of the form \fBoml_inject_MPNAME\fR(\fIOmlMP*\fR mp, \&...), where \fBMPNAME\fR is the name of the \fIMP\fR that is passed as \fBmp\fR\&. The remaining arguments are C\-typed variables constituting the sample to be injected in the \fIMP\fR\&.
.sp
Continuing with the auto\-generated example from above, injecting a sample in the \fImemory\fR \fIMP\fR can be done as
.sp
.if n \{\
.RS 4
.\}
.nf
oml_inject_memory(g_oml_mps_foo\->memory, ram, total, free, used, free_percent, used_percent);
.fi
.if n \{\
.RE
.\}
.sp
where \fIram\fR, \fItotal\fR, \fIfree\fR, \fIused\fR, \fIfree_percent\fR and \fIused_percent\fR are assumed to be variables updated by the rest of the application code\&.
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBImplementing injection code manually\fR
.RS 4
.sp
The \fBomlc_inject\fR(3) function accepts an \fIMP\fR handle and a vector of \fBOmlValueU\fR(3) objects\&. These values MUST always be initialised first with \fBomlc_zero\fR(3) or \fBomlc_zero_array\fR(3)\&. The programmer should first load up the vector with new values to be measured using the \fBomlc_set_\fR* macros, and then call \fBomlc_inject\fR(3)\&. If string or blobs were affected to some of the \fBOmlValueU\fR(3), these have to be reset with \fBomlc_reset_string\fR(3) or \fBomlc_reset_blob\fR(3) so any allocated memory is properly cleared\&. For instance, here is how a measurement injection might look for the \fIMP\fR definition above:
.sp
.if n \{\
.RS 4
.\}
.nf
\&.\&.\&.

OmlMP *mp = omlc_add_mp("packet_info", mp_def);

\&.\&.\&.

uint32_t source_id;
uint32_t destination_id;
uint32_t packet_length;
double weight;
char *protocol;

\&.\&.\&.

/* Some application\-specific code to obtain new values for the variables above */

\&.\&.\&.

{
   OmlValueU values[5];

   omlc_zero_array(values, 5);

   omlc_set_uint32 (values[0], source_id);
   omlc_set_uint32 (values[1], destination_id);
   omlc_set_uint32 (values[2], packet_length);
   omlc_set_double (values[3], weight);
   omlc_set_string (values[4], protocol);

   omlc_inject (mp, values);

   omlc_reset_string (values[4]); /* Free potentially allocated space */
}
.fi
.if n \{\
.RE
.\}
.sp
The vector must be loaded with values in the same order as the original definition of the fields of the \fIMP\fR in the call to \fBomlc_add_mp\fR(3)\&. The call to \fBomlc_inject\fR(3) can be repeated as many times as the program wants to make measurements for a given \fIMP\fR\&.
.sp
OML uses an opaque data structure, \fBOmlValueU\fR(3) to store arbitrary data types\&. This structure can contain chunks of allocated memory and should therefore be properly initialised before use (with the \fBomlc_zero\fR(3) and \fBomlc_zero_array\fR(3) functions\&.
.sp
OML defines the following types and setters:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

\fIOML_INT32_VALUE\fR
(\fBomlc_set_int32\fR(3))
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

\fIOML_UINT32_VALUE\fR
(\fBomlc_set_uint32\fR(3))
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

\fIOML_INT64_VALUE\fR
(\fBomlc_set_int64\fR(3))
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

\fIOML_UINT64_VALUE\fR
(\fBomlc_set_uint64\fR(3))
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

\fIOML_DOUBLE_VALUE\fR
(\fBomlc_set_double\fR(3))
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

\fIOML_STRING_VALUE\fR
(\fBomlc_set_string\fR(3),
\fBomlc_reset_string\fR(3))
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

\fIOML_BLOB_VALUE\fR
(\fBomlc_set_blob\fR(3),
\fBomlc_reset_blob\fR(3))
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

\fIOML_GUID_VALUE\fR
(\fBomlc_set_guid\fR(3))
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

\fIOML_BOOL_VALUE\fR
(\fBomlc_set_bool\fR(3))
.RE
.sp
Each of the first four integer types maps to an underlying equivalent type from the C standard header \fBstdint.h\fR(0)\&. These types should be used in calls to the \fBomlc_set_\fR* macros\&. They are:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

\fIint32_t\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

\fIuint32_t\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

\fIint64_t\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

\fIuint64_t\fR
.RE
.sp
The \fIOML_DOUBLE_VALUE\fR type maps to an underlying C double\&.
.sp
The \fIOML_STRING_VALUE\fR maps to a nil\-terminated C string\&. Memory will be dynamically allocated (or reused) when a value of this type is set to an \fBOmlValueU\fR(3)\&.
.sp
The \fIOML_BLOB_VALUE\fR maps to an arbitrary block of binary data, of a given size\&. It is handled in a way similar to \fIOML_STRING_VALUE\fR, save for the nil\-termination and automatic size calculation\&.
.sp
The \fIOML_GUID_VALUE\fR type can be used to create logical groups of samples, either within the same \fIMP\fR, or across \fIMPs\fR\&. For example, parameters from the IP and TCP headers of a TCP packet should be reported in separate \fIMPs\fR (as not all IP packets have TCP payload)\&. However, it is desirable to link these tuples together\&. Adding an \fIOML_GUID_VALUE\fR field in both \fIMPs\fR, which can be filled with the same GUID returned \fBomlc_guid_generate\fR(3) would allow to join the relevant information about this packet at a later time, during analysis\&. Similarly, if multiple samples in an \fIMP\fR belong to the same logical group (e\&.g\&., an array), they can be linked using the same mechanism, by adding an \fIOML_GUID_VALUE\fR field to that \fIMP\fR, and generating a new \fIoml_guid_t\fR every time a new group needs to be created\&. To fill \fIOML_GUID_VALUE\fR fields where grouping is not needed, a default \fINULL\fR value is available as \fIOMLC_GUID_NULL\fR\&.
.sp
The \fIOML_BOOL_VALUE\fR simply encapsulate a boolean value\&. Anything that is not 0 is assumed to be true\&. There is however no guarantee that a non\-zero boolean will retain the actual (integral) value which was used to set it, beyond its logical truth value\&.
.sp
\fBliboml2\fR currently also defines an \fIOML_LONG_VALUE\fR that maps to a C \fIlong\fR type, but this type is deprecated because it can change size between 32\-bit and 64\-bit platforms\&. It will be removed from the API at some point in the future\&. The library internally clamps \fIOML_LONG_VALUE\fR \fIMP\fR fields to the most positive and negative values that will fit in an \fIint32_t\fR object before sending them to the \fBoml2-server\fR(1) or a local measurement file\&. \fIOML_LONG_VALUE\fR should not be used in new applications\&.
.RE
.SS "Building"
.sp
Applications using \fBliboml2\fR must include the \fI\-loml2\fR flag on the linker command line to link against the client library\&.
.SH "EXAMPLE"
.sp
The following is a fully\-functional example application that counts from 1 to 1000 and outputs the value of the counter as an unsigned integer, a string, and a double at each step:
.sp
.if n \{\
.RS 4
.\}
.nf
#include <stdio\&.h>
#include <stdlib\&.h>
#include <oml2/omlc\&.h>

int main (int argc, const char **argv)
{
  int result = omlc_init ("Simple", &argc, argv, NULL);
  if (result == \-1) {
    fprintf (stderr, "Could not initialise OML\en");
    exit (1);
  } else if (result == 1) {
    fprintf (stderr, "OML was disabled by the user, exiting\en");
    exit (0);
  }

  OmlMPDef mp_def [] = {
    { "count", OML_UINT32_VALUE },
    { "count_str", OML_STRING_VALUE },
    { "count_real", OML_DOUBLE_VALUE },
    { NULL, (OmlValueT)0 }
  };

  OmlMP *mp = omlc_add_mp ("counter", mp_def);

  if (mp == NULL) {
    fprintf (stderr, "Error: could not register Measurement Point \*(Aqcounter\*(Aq");
    exit (1);
  }

  omlc_start();

  int i = 0;
  for (i = 0; i < 1000; i++) {
    uint32_t count = (uint32_t)i;
    char count_str[16];
    double count_real = (double)i;
    OmlValueU values[3];

    omlc_zero_array(values, 3);

    snprintf(count_str, sizeof(count_str), "%d", i);

    omlc_set_uint32 (values[0], count);
    omlc_set_string (values[1], count_str);
    omlc_set_double (values[2], count_real);

    omlc_inject (mp, values);

    omlc_reset_string(values[1]);
  }


  omlc_close();

  return 0;
}
.fi
.if n \{\
.RE
.\}
.sp
The following command should be sufficient to compile this program:
.sp
.if n \{\
.RS 4
.\}
.nf
$ gcc \-o counter counter\&.c \-loml2
.fi
.if n \{\
.RE
.\}
.sp
Here is an example command line to run this application with a default set of filters:
.sp
.if n \{\
.RS 4
.\}
.nf
$ \&./counter \-\-oml\-id myid \-\-oml\-domain count \-\-oml\-collect file:\-
.fi
.if n \{\
.RE
.\}
.sp
The output from this command will appear on the terminal because we told OML to use the standard output (\fB\-\-oml\-collect file:\-\fR)\&. Here is what it looks like:
.sp
.if n \{\
.RS 4
.\}
.nf
INFO   OML Client 2\&.x\&.y [OMSPv5] Copyright 2007\-2014, NICTA
protocol: 5
domain: count
start\-time: 1283160287
sender\-id: myid
app\-name: Counter
schema: 1 Counter_counter count:uint32 count_str:string count_real:double
content: text


0\&.797713        1       1       0       0       0\&.000000
0\&.797736        1       2       1       1       1\&.000000
0\&.797748        1       3       2       2       2\&.000000
0\&.797760        1       4       3       3       3\&.000000
0\&.797774        1       5       4       4       4\&.000000
0\&.797785        1       6       5       5       5\&.000000
0\&.797796        1       7       6       6       6\&.000000
\&.\&.\&.
.fi
.if n \{\
.RE
.\}
.sp
An easy way to create more complicated applications is to use \fBoml2-scaffold\fR(1)\&.
.SH "PORTING PRE-2.9 APPLICATIONS"
.sp
In between OML 2\&.8 and 2\&.9, a heavy refactoring of the lower layers happened to better track the memory used, and reduce memory leaks\&. Unfortunately, this change could not be hidden from the higher layers, as the API was extended with the introduction of initialisers destructors for \fBOmlValueU\fR(3) variables, with proper management of dynamic memory allocation\&.
.sp
The shared library\(cqs version has been bumped from 0\&.8\&.1 to 9\&.0\&.0, so old binaries could still work properly (on distributions supporting multiple library versions, such as Debian)\&. However, this means these old binaries will not benefit from the new features of OML 2\&.9 onwards\&.
.sp
Porting pre\-2\&.9 instrumentations to OML 2\&.9 is however relatively easy\&. Whenever \fBOmlValueU\fR(3), or arrays thereof, are declared, they MUST be properly initialised prior to any use\&. Not doing so might result in cryptic segmentation faults, or weird ghostly data being collected\&. Refer to Implementing injection code manually and the example above to see where calls to \fBomlc_zero\fR(3) (or \fBomlc_zero_array\fR(3)), and \fBomlc_reset_string\fR(3) and \fBomlc_reset_blob\fR(3) should be added to your code\&.
.sp
Additionally, omlc_set_const_string() is deprecated, as it did not have much significance\&. The string is now always duplicated into separate storage to ensure integrity regardless of how the instrumented application manipulates its original data after injection\&.
.sp
All new instrumentations should however avoid using \fBomlc_inject\fR(3) directly, and rely on the code generation capabilities of \fBoml2-scaffold\fR(1) instead\&. It is also recommended that these changes be taken as an opportunity to port old applications to \fBoml2-scaffold\fR(1) too\&.
.SH "BUGS"
.sp
If a problem you are experiencing is not addressed in the FAQ (http://oml\&.mytestbed\&.net/projects/oml/wiki/FAQ_and_Support) nor already present in the list of know bugs (http://oml\&.mytestbed\&.net/projects/oml/issues)\&. You could discuss it on the mailing list (details and archives at http://oml\&.mytestbed\&.net/tab/show?id=oml)\&.
.sp
It is however advisable to open a ticket on our issue tracker at http://oml\&.mytestbed\&.net/projects/oml/issues/new\&. Don\(cqt forget to include details such as client and server logs (at \fI[\-\-oml\-log\-level|\-d] 2\fR)\&. It also helps if you can share the source code of a (minimal, if possible) example reliably triggering the problem\&.
.SH "SEE ALSO"
.SS "Manual Pages"
.sp
\fBoml2-server\fR(1), \fBliboml2\fR(1), \fBliboml2.conf\fR(5), \fBoml2-scaffold\fR(1)
.sp
\fBomlc_init\fR(3), \fBomlc_add_mp\fR(3), \fBomlc_start\fR(3), \fBomlc_inject\fR(3), \fBomlc_close\fR(3)
.sp
\fBOmlValueU\fR(3)
.SS "OML User Manual"
.sp
http://oml\&.mytestbed\&.net/projects/oml/wiki/Documentation
