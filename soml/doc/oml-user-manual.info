This is oml-user-manual.info, produced by makeinfo version 4.13 from
oml-user-manual.texi.

Copyright (C) 2009-2014, NICTA

   Locked Bag 9013
Alexandria NSW 1430
AUSTRALIA

File: oml-user-manual.info,  Node: Top,  Next: Introduction,  Up: (dir)

OML User Manual
***************

This manual is for OML, The OMF Measurement Library, version 2.3.0, a
package containing a software framework for distributed measurement
collection in network testbeds or clustered simulation experiments.

   OMF is the cOntrol and Management Framework for maintaining network
testbeds and running distributed networking experiments on network
testbeds.  You can find out more about OMF at:

   <http://www.mytestbed.net>

   The core of OML consists of a measurement server and a client
library.  Users of OML can write applications that use the functions of
the client library to record measurements from an experiment running on
one network host, and either write them to a file locally on that host,
or send them to the server over a network connection.  The server can
record results of multiple experiments running simultaneously on
multiple network hosts, and writes them to a database on the machine
hosting the server.  It is even possible to run experiments on network
hosts that are sometimes disconnected, using the OML proxy server.

* Menu:

* Introduction::                Introduction to OML.
* Basic concepts of OML::
* Client applications::
* Server::                      Using the OML server and the OML proxy server.
* Custom Filters::              How to design custom filters for use with OML.
* Non-instrumented Applications::  How to use OML with third party programs when you don't have source code.
* Language Bindings::           Bindings for languages other than C/C++.
* Measurement Database::        Querying the measurement database.


* Server protocol::
* Index::                       Index.

 --- The Detailed Node Listing ---

Introduction

* What is OML?::
* Organization of this manual::

Client application

* Client configuration::        How to configure an OML client application

Client configuration

* Command line::                Configuring the OML client from the command line
* XML configuration::           Configuring the OML client using an XML file
* Configuration errors::        What happens if you make a mistake configuring OML

Command line

* omlid::
* omldomain::
* omlcollect::
* omlsamples::
* omlinterval::
* omlconfig::
* omllogfile::
* omlloglevel::
* omlnoop::
* omllistfilters::
* omlhelp::

XML configuration

* Root element::                The root element of the XML file.
* Data collectors::
* Definining measurement points::  How to define what measurements to collect.
* Defining filters::            How to create filters on each MP.
* Example XML configuration::

Custom Filters

* Anatomy of a filter::         The basic components of an OML filter.
* Filter API::                  The interface for filter writers.

Filter API

* Utility functions::           Functions for operating on filters.
* Filter function prototypes::  The API that new filters must conform to.
* Filter Tutorial::             A tutorial showing how to define your own filters.

Bindings for other languages

* Ruby::                        Bindings for Ruby
* Python::                      Bindings for Python

Server protocol

* Protocol headers::
* Binary measurement data::
* Text measurement data::

Protocol headers

* Protocol::
* app-name::
* sender-id::
* domain::
* experiment-id::
* start_time::
* start-time::
* content::
* schema::

Binary measurement data

* LONG_T type::
* DOUBLE_T type::
* DOUBLE_NAN type::
* STRING_T type::


File: oml-user-manual.info,  Node: Introduction,  Next: Basic concepts of OML,  Prev: Top,  Up: Top

1 Introduction
**************

OML is the OMF Measurement Library.  It was created from a need to
filter, collect, store, retrieve, and analyze measurements produced in
the course of running experiments on large testbed networks, and thence
comes its name: OMF is the cOntrol and Management Framework that
provides mechanisms for defining and executing experiments on a testbed
network, and we wrote OML to collect measurements from OMF experiments.

   Why is a measurement library like OML necessary?  An experiment or a
simulation running on a single computer can generate a large amount of
measurement data, but this does not pose a significant challenge to the
experimenter because she can organize it using the local filesystem.
An experiment that is run on the nodes of a network, such as a
simulation cluster or a testbed network, generates even more data but
distributes it over many nodes.  It then becomes a challenge to
collect, organize, and store the measurement data in a central
location.  Ad-hoc approaches to this problem tend to be arduous and
error-prone.  OML provides tools to solve the problem systematically
and conveniently.

* Menu:

* What is OML?::
* Organization of this manual::


File: oml-user-manual.info,  Node: What is OML?,  Next: Organization of this manual,  Up: Introduction

1.1 What is OML?
================

OML is a suite of software components that cooperate to collect and
store measurement data.  The two main components are the client
library, `liboml2', and the server, `oml2-server'.

   An experimenter writes a "client application" that performs some
measurements, and uses functions provided by `liboml2' to send the
measurements to either a file on the local filesystem, an OML server
running on another network host, or both.  It is also possible to
configure `liboml2' to do some filtering of the measurements before
they are sent to the file or server.

   The `oml2-server' application is a network application that listens
for connections (either UDP or TCP) from client applications running on
other network hosts.  The client applications connect to the server and
transmit measurements to it via the network.  The server then stores
the measurements in a database.

   Both `oml2-server' and `liboml2' are written in C, and they were
originally written for the Linux operating system on x86 machines,
although they should be portable to other UNIX-like operating
systems.(1)

   ---------- Footnotes ----------

   (1) Currently we don't have any plans to actively port OML to other
operating systems or architectures, although we know of people who are
using OML on ARM CPU's, and we know OML compiles and runs on MacOS X.
We gladly accept patches, though!


File: oml-user-manual.info,  Node: Organization of this manual,  Prev: What is OML?,  Up: Introduction

1.2 Organization of this manual
===============================

This manual begins with a tour of OML in *note Basic concepts of OML::,
which describes the overall architecture, how the client library works,
and how the server works, conceptually.  Then in *note Client
applications::, we show how to write your experiment application to take
advantage of OML and how to configure the OML client library's sampling,
filtering, and measurement output at run time.  *note Server::,
discusses both the OML server, which stores measurements in a database
for later retrieval, and the OML proxy server, which can used to collect
measurements on network nodes that might sometimes be disconnected from
the network, such as mobile nodes.

   The `liboml2' library uses a general filtering architecture to
filter measurements before sending them to a file or to an OML server.
This architecture is extensible: you can write your own custom filters.
*note Custom Filters:: expands on the concepts in *note Client
applications:: to show you how to do this, and provides a detailed
reference for the filter writing API.


File: oml-user-manual.info,  Node: Basic concepts of OML,  Next: Client applications,  Prev: Introduction,  Up: Top

2 Basic concepts of OML
***********************


File: oml-user-manual.info,  Node: Client applications,  Next: Server,  Prev: Basic concepts of OML,  Up: Top

3 Client application
********************

* Menu:

* Client configuration::        How to configure an OML client application


File: oml-user-manual.info,  Node: Client configuration,  Up: Client applications

3.1 Client configuration
========================

Client applications can be given options on the command line to
configure various aspects of the behaviour of the OML client library.
They can also be configured more extensively using a configuration file
in XML format.  For some users the command line configuration will be
sufficient, but the XML format provides more power for more
sophisticated measurement needs.

* Menu:

* Command line::                Configuring the OML client from the command line
* XML configuration::           Configuring the OML client using an XML file
* Configuration errors::        What happens if you make a mistake configuring OML


File: oml-user-manual.info,  Node: Command line,  Next: XML configuration,  Up: Client configuration

3.1.1 Command line
------------------

The client application must initialize OML with a call to
`omlc_init()', passing it the programme's command line argument vector
and count.  The `omlc_init()' function scans the command line for
options that it understands, configures OML according to those options,
and then removes the OML-specific options from the argument vector.
This allows the client application to have its own command line options
without needing to worry about processing OML options as well.

   To see the available options, build your client application, linking
with `-loml2', and then execute it with the `--oml-help' option:
     $ my-oml-app --oml-help
   Here is how the `main()' function of a typical OML client
application might look:

     int main (int argc, char** argv)
     {
       int res;

       res = omlc_init ("my-oml-app", &argc, &argv, NULL);
       if (res < 0)
          return -1;  /* OML failed to initialise */
       else if (res == 1)
          return 0;  /* OML was disabled (e.g., with --oml-noop) */

       /* Do our own options processing, if required */
       ...
       /* Add MP's with omlc_add_mp() */
       ...

       res = omlc_start ();

       if (res)
          return (-2);  /* OML failed to start */

       /* Do the application, collect measurements with omlc_inject() */
       ...

       return 0; /* Program ran and finished successfully */
     }

   The call to `omlc_init()' parses the OML command line options and
configures the library.  The `omlc_start()' function is responsible for
creating the filter configuration.  If there is no XML configuration
file specified (i.e. `--oml-config' is not given) then a default filter
configuration is used.  In this configuration, there is a single
collection URI, specified by either `--oml-collect', and every MP that
has been previously registered by a call to `omlc_add_mp()' is given a
filter for every element of its input n-tuple.  The filter type for
each element of the n-tuple is chosen automatically:

   * If the element is an `OML_LONG_VALUE' or an `OML_DOUBLE_VALUE'
     then the averaging filter `avg' is used;

   * If the elment is an `OML_STRING_VALUE', then the first filter,
     `first', is used.

   The following subsections describe all the OML command line options
in detail.

* Menu:

* omlid::
* omldomain::
* omlcollect::
* omlsamples::
* omlinterval::
* omlconfig::
* omllogfile::
* omlloglevel::
* omlnoop::
* omllistfilters::
* omlhelp::


File: oml-user-manual.info,  Node: omlid,  Next: omldomain,  Up: Command line

3.1.1.1 `--oml-id' ID
.....................

Set the client application's node ID.  This is not required if output is
only going to a file, but it is mandatory if output is going to an OML
server, as the OML server uses the node ID (and the experimental domain)
to distinguish between measurements from different OML clients in the
network.


File: oml-user-manual.info,  Node: omldomain,  Next: omlcollect,  Prev: omlid,  Up: Command line

3.1.1.2 `--oml-domain' ID
.........................

Set the client application's experimental domain.  This is not required
if output is only going to a file, but it is mandatory if output is
going to an OML server, as the OML server uses the domain (and the node
ID) to distinguish between measurements from different OML clients in
the network.


File: oml-user-manual.info,  Node: omlcollect,  Next: omlsamples,  Prev: omldomain,  Up: Command line

3.1.1.3 `--oml-collect' URI
...........................

Send measurement output to the collection point indicated by the URI
parameter.  The URI can specify either UDP or TCP protocol, together
with a host and port number to connect to.  For example:
     --oml-collect tcp:[2001:db8::1]:1234
   would connect to port 1234 on machine 192.0.2.1 using TCP protocol.


File: oml-user-manual.info,  Node: omlsamples,  Next: omlinterval,  Prev: omlcollect,  Up: Command line

3.1.1.4 `--oml-samples' N
.........................

Set the sampling policy to compute filter outputs every N input samples
for all defined measurement points.  Only one of `--oml-samples' and
`--oml-interval' should be specified at the same time, otherwise an
error will occur.


File: oml-user-manual.info,  Node: omlinterval,  Next: omlconfig,  Prev: omlsamples,  Up: Command line

3.1.1.5 `--oml-interval' PERIOD
...............................

Set the sampling policy to compute filter outputs every PERIOD seconds
for all defined measurement points.  Only one of `--oml-interval' and
`--oml-samples' should be specified at the same time, otherwise an
error will occur.


File: oml-user-manual.info,  Node: omlconfig,  Next: omllogfile,  Prev: omlinterval,  Up: Command line

3.1.1.6 `--oml-config' CONFIG-FILE
..................................

Use an XML CONFIG-FILE to configure OML.  *Note XML configuration::.


File: oml-user-manual.info,  Node: omllogfile,  Next: omlloglevel,  Prev: omlconfig,  Up: Command line

3.1.1.7 `--oml-log-file' LOG-FILE
.................................

Log debug, informational, warning, and error messages to file LOG-FILE.
If LOG-FILE is ``-'', then the output goes to the client application's
standard output stream.  Not all of the four levels of logging are sent
to the log file.  This is controlled by `--oml-log-level', *Note
omlloglevel::.


File: oml-user-manual.info,  Node: omlloglevel,  Next: omlnoop,  Prev: omllogfile,  Up: Command line

3.1.1.8 `--oml-log-level' LEVEL
...............................

Control the amount of information logged to the OML log file.  The log
LEVEL is a number from 1 to 4:
   * LEVEL=1: Log only error messages to the log file.

   * LEVEL=2: Log error messages and warnings to the log file.

   * LEVEL=3: Log errors, warnings, and informational messages to the
     log file.

   * LEVEL=4: Log errors, warnings, informational messages and
     debugging messages to the log file.


File: oml-user-manual.info,  Node: omlnoop,  Next: omllistfilters,  Prev: omlloglevel,  Up: Command line

3.1.1.9 `--oml-noop'
....................

Don't write any measurements to file or any servers.  This is useful if
the OML client application needs to be run as part of a larger
experiment, but its output is not interesting for this particular
experiment.


File: oml-user-manual.info,  Node: omllistfilters,  Next: omlhelp,  Prev: omlnoop,  Up: Command line

3.1.1.10 `--oml-list-filters'
.............................

Print out the available filter types, for use in the XML configuration
file, then exit.


File: oml-user-manual.info,  Node: omlhelp,  Prev: omllistfilters,  Up: Command line

3.1.1.11 `--oml-help'
.....................

Print out a usage message listing all the available options, then exit.


File: oml-user-manual.info,  Node: XML configuration,  Next: Configuration errors,  Prev: Command line,  Up: Client configuration

3.1.2 XML configuration
-----------------------

     Current implementation status: With reference to the text below,
     the parser is not fully implemented.  In particular, the filter
     parameters element `<fp/>' is parsed but the key/value pair is not
     sent to the filter's `set()' function.  Also, the filter
     definition element `<f/>' has a defined attribute `multi_pnames',
     but it isn't processed or used in any way.

   While the command line provides a basic method for configuring OML,
with averaging filters on numeric measurements and either sample count
or interval based filtering, the full power of OML's filtering
capabilities can only be accessed via its XML configuration file
format.  The XML format allows the user of the OML client application
to choose multiple different filters for each measurement stream, and
to send the resulting filtered measurements to multiple different
destinations.  To use an XML file for configuring OML, pass it the
`--oml-config' option and specify a file as the argument.  For example:
     $ my-oml-app --oml-config config.xml ...

* Menu:

* Root element::                The root element of the XML file.
* Data collectors::
* Definining measurement points::  How to define what measurements to collect.
* Defining filters::            How to create filters on each MP.
* Example XML configuration::


File: oml-user-manual.info,  Node: Root element,  Next: Data collectors,  Up: XML configuration

3.1.2.1 Root element
....................

The XML file must have a root element with tag `<omlc/>'.  The root
element can also specify the node identifier and the experiment
identifier, using the `id' and `domain' attributes, respectively.  For
example, suppose that the client is running on a node called "node-21",
and that this experiment is testing a new WiFi networking algorithm
called "xtream-wifi".  The XML configuration file for this experiment
might look like this:

     <omlc id="node-21" domain="xtream-wifi-1">
     ...
     </omlc>

   The `id' and `domain' attributes are not mandatory if results are
being written to a file, however the OML client library can't send
measurement output to an OML server without them.  In that case,
`omlc_start()' will return an error.


File: oml-user-manual.info,  Node: Data collectors,  Next: Definining measurement points,  Prev: Root element,  Up: XML configuration

3.1.2.2 Data collectors
.......................

Under the root node there must be a list of one or more `<collect/>'
elements.  The collect element indicates a data destination (i.e. a
data "collector").  A data collector can represent either:

   * a file on the local filesystem;

   * an OML server located on a network accessible from the machine on
     which the client application is running; or

   * an OML proxy server located on the same machine as the client
     application.

   The destination is specified using the `url' attribute of the
`<collect/>' element.  The following protocols are available:

  1. `file:' - writes measurement data to a file on the local
     filesystem.  For instance `<collect url="file:/tmp/my-data.txt"/>'
     will write to the file `/tmp/my-data.txt'.  Relative file names
     are interpreted relative to the current working directory of the
     OML client application when it launched.  A URL of `file:-' sends
     the output to the client application's standard output stream.

  2. `tcp:' - writes measurement data to a TCP connection that the
     client library establishes. The destination host and port are
     encoded in the URL.  For instance, `<collect
     url="tcp://10.42.54.2:3003"/>' will write data for this collector
     to TCP port 3003 of machine 10.42.54.2.

  3. `udp:' - writes measurement data to a UDP connection that the
     client library establishes.  The destination host and port are
     encoded in the URL.  For instance, `<collect
     url="udp://10.42.54.3:3004"/>'.

   The `url' attribute is a required attribute; it is an error to omit
it.

   The other (non-mandatory) attribute is `encoding' which specifies
the protocol encoding to use when communicating with the destination.
The regular OML server and the OML proxy server both understand the
same protocol, and are interchangeable from the point of view of the
OML client application.

   There are currently two types available:

  1. `text' - where tuples are separated by newlines and each element in
     a tuple is separated by a comma.

  2. `binary' - tuples and their values are encoded with a more
     efficient TLV-like protocol.

   If the encoding is not specifcially specified, the `binary' encoding
is used for all urls except the `file' type.


File: oml-user-manual.info,  Node: Definining measurement points,  Next: Defining filters,  Prev: Data collectors,  Up: XML configuration

3.1.2.3 Defining measurement points
...................................

The `<collect/>' element groups one or more `<mp/>' elements.  An
`<mp/>' element is a representation of a Measurement Point (MP).  Each
`<mp/>' has a `name' attribute, which is mandatory, and either a
`samples' attribute or an `interval' attribute.  The `name' attribute
must match the name of an MP that the client application registered
using `omlc_add_mp()'.

   If `samples=n' is specified, where `n' is an integer, then the MP
will call its filters' `output()' functions after every `n' samples,
resulting in measurements being written to the MP's collector.  If
`interval=T', where `T' is a floating point number, then the MP will
call its filters' `output()' functions every `T' seconds, so the
filtered measurements will be sent to the collector's data store at
that periodic interval.  Specifying both `samples' and `interval' on
the same `<mp/>' element is an error.

   Each `<mp/>' groups a number of filter specification elements, which
are given using the `<f/>' tag.  Thus, an example OML configuration
file with one collector, one MP, and two filters might look like the
following:

     <omlc id="node-21" domain="xtream-wifi-1">
           <collect url="file:xtream-wifi-1-output.txt">
                    <mp name="packets" interval=1.0>
                        <f .../>
                        <f .../>
                    </mp>
           </collect>
     </omlc>

   This assumes that the "xtream-wifi" client application has created
an MP named "packets".  This configuration could be used, for instance,
to count the number of packets received per second (since the
`interval' attribute is given with a 1 second period) using the first
filter, and also the delay between packets using the second filter.


File: oml-user-manual.info,  Node: Defining filters,  Next: Example XML configuration,  Prev: Definining measurement points,  Up: XML configuration

3.1.2.4 Defining filters
........................

The `<f/>' element is used to select the type and parameters for the
filters attached to this MP.  All measurement samples injected into the
MP by the client application using calls to `omlc_inject()' will be fed
as input samples to all filters grouped under the MP.  Because the
injected samples are n-tuples, and most (but not all) filters are only
interested in one element of the n-tuple, the `<f/>' tag allows you to
select which element of the n-tuple gets sent to which filter.

   A filter is typically specified as follows:
     <f fname="avg" sname="ip_len_avg" pname="ip_len"/>
   This filter might be used, for instance, to compute the average
length of IP packets received.  The `fname' attribute specifies the type
of filter to create.  In this case, an averaging filter ("avg") is
being used.  The `sname' attribute gives a name to the filter, which
will appear in the schema sent to the datastore, so that outputs from
this filter can be distinguished from others.  Finally, the `pname'
attribute selects which element of the MP's input n-tuple to use as the
primary filter input.

   The names of the available filter types can be determined by giving
the `--oml-filter-types' option to the client application.  The names
given there are appropriate to be used as the value of the `fname'
attribute.

     Alternative proposal: Having three different attributes called
     "`xname'" is a bit confusing, and makes it difficult for a new
     user to remember what the "x" part means.  We could as an
     alternative rename these attributes:

        * `fname' => `type'

        * `sname' => `name'

        * `pname' => `parameter'

     With this change the above example would look like this:
          <f name="ip_len_avg" type="avg" parameter="ip_len"/>
     This makes it clear that the type of filter is an averaging filter,
     the filter's identifier is `ip_len_avg', and it is filtering the
     MP's `ip_len' parameter.

   In this case, the filter is taking its primary input from the
`ip_len' parameter of the MP's n-tuple.  In general, the parameter name
specified via the `<f/>' tag's `pname' attribute must match the name of
a parameter in the MP's definition, as supplied in a call to
`oml_add_mp()' in the OML client application.  If the name specified in
the `pname' attribute doesn't match any parameter of the MP under which
the filter is defined, an error occurs.  The `sname' attribute can be
any string.

   An `<f/>' element can optionally contain `<fp/>' children that allow
for setting filter properties.  We call them properties to avoid
confusion with the MP's parameters.  A property is a way of customizing
a filter's behaviour.  Properties are typed, named values.  Allowable
types are `integer', `double', and `string'.  For instance, suppose a
(hypothetical) filter type exists called `fft' that computes the Fast
Fourier Transform of its input data.  It might have an integer
parameter `N' representing the size of the FFT input/output, and string
parameter `dir' to select between an FFT and an IFFT.  This could be
represented as follows:

     <f sname="vibration-fft" fname="fft" pname="displacement">
        <fp name="N" type="integer">32</fp>
        <fp name="dir" type="string">FFT</fp>
     </f>

   In this case the FFT size chosen is 32 and the forward FFT will be
computed, not the inverse FFT.


File: oml-user-manual.info,  Node: Example XML configuration,  Prev: Defining filters,  Up: XML configuration

3.1.2.5 Example XML configuration
.................................

The previous sections described everything required to configure and
OML client application.  Here is a slightly longer example of an OML
XML configuration file.

     <omlc domain="exp99" id="node11">
         <collect url="tcp:localhost:15500">
             <mp name="omlsigar" interval="2" >
                 <f fname="avg" sname="cpu_user" pname="cpu_user" />
             </mp>
         </collect>

         <collect url="tcp:192.0.2.1:15502">
             <mp name="omlsigar" interval="2" >
                 <f fname="avg" sname="rx_bytes" pname="rx_bytes"/>
                 <f fname="histogram" sname="rx_hist" pname="rx_bytes">
                     <fp name="key">rx_bytes</fp>
                 </f>
             </mp>
         </collect>

         <collect url="file:-">
             <mp name="omlsigar" interval="2" >
                 <f fname="avg" sname="rx_bytes" pname="rx_bytes"/>
                 <f fname="avg" sname="tx_bytes" pname="tx_bytes"/>
             </mp>
         </collect>
     </omlc>

   This example sends data to an OML sever at the localhost port 15500,
to another OML server at remote machine 192.0.2.1 port 15502, and to
the standard output on the local machine.  The localhost server records
the average CPU user time; the remote server records both the average
received bytes and a histogram of the average received bytes; and the
standard output prints both the average received and transmitted bytes.


File: oml-user-manual.info,  Node: Configuration errors,  Prev: XML configuration,  Up: Client configuration

3.1.3 Configuration errors
--------------------------

If an error is detected in the way that OML has been configured, either
on the command line or in an XML configuration file, then
`omlc_start()' will return with an error, and `omlc_init()' might as
well.  In that case, the client application will probably not send
measurements to the datastores; certainly not in the manner intended.
It is probable that measurements will be lost, and this behaviour is
undefined.

   Client applications must check the return values of both
`omlc_init()' _and_ `omlc_start()'.  If either returns an error, the
client application should print a diagnostic message and quit with an
error code.  The OML log file will contain log messages indicating the
nature of the problem.  You should inspect these log messages and
correct the problem before continuing.


File: oml-user-manual.info,  Node: Server,  Next: Custom Filters,  Prev: Client applications,  Up: Top

4 Server
********


File: oml-user-manual.info,  Node: Custom Filters,  Next: Non-instrumented Applications,  Prev: Server,  Up: Top

5 Custom Filters
****************

OML comes with several built-in filters already available for use by
your applications.  The currently defined filters are:

   * Average filter:  output the average, min and max of all the
     samples since the beginning of the experiment.

   * First filter:  output only the first sample in each sampling
     interval, and discard the rest.

   * Histogram filter:  record and output a histogram from the received
     measurements.

   For many experiments these filters will be adequate.  OML provides a
mechanism for experimenters to write custom filters in situations where
the built-in filters do not provide the required functionality.  This
chapter describes the API for defining custom filters in your
application, and gives an example of how to use it.

* Menu:

* Anatomy of a filter::         The basic components of an OML filter.
* Filter API::                  The interface for filter writers.


File: oml-user-manual.info,  Node: Anatomy of a filter,  Next: Filter API,  Up: Custom Filters

5.1 Anatomy of a filter
=======================

An OML filter is a processing element that accepts a stream of values
from an MP and produces output that is some function of the input
stream.  Typically a filter should produce output samples at a reduced
rate compared to the input sample rate, although OML does not enforce
this rule.  One significant reason for filtering is to reduce the
amount of data produced by an experiment to a more manageable level.
Another is to provide multiple alternative ways for looking at the
experiment's result set.

   Each filter is attached to an MP when it is created.  The filter
input stream therefore consists of n-tuples, where n is the width of
the MP's input (as defined by a call to `omlc_add_mp()').  The output
stream of the filter consists of m-tuples, where m is defined by the
filter writer.

   Note that the output width, m, is fixed by the filter writer and
cannot change at runtime, whereas the input width, n, is defined by the
MP to which the filter is attached, and is by nature a dynamic runtime
quantity.

   Internally to the OML client library, a description of every type of
filter is stored in a factory.  This description consists of the
following:

   * a create function, called `create()' in the following discussion;

   * a parameter setting function, called `set()';

   * a new sample input function, called `input()';

   * a filter output function, called `output()';

   * a meta function, called `meta()'; and

   * an output description.

   These functions and the output description are all provided by the
filter writer via a call to `omlf_register_filter()'.  The
`omlf_register_filter()' function and the required API for all of the
user-provided functions are described fully in *note Filter API::.

   New filters instances are created during the call to `omlc_start()',
according to either OML command line options or according to the XML
configuration file, if specified. There can be multiple instances of
each type of filter, including user-defined filters. Each instance is
created by a call to the `create()' function for the filter type. The
`create()' function for a filter should allocate memory for any
internal state that it needs to maintain, and should initialize the
state appropriately.

   When the application begins running and generating measurement data,
every time an MP receives new data from the application (in a call to
`omlc_inject()') it passes the sample data to all of its attached
filters by calling their `input()' functions.  The input function
should update the internal state of the filter to reflect the new
sample.

   Each MP is defined with a sampling policy: it produces outputs either
when a set time interval has elapsed, or when a set number of samples
has been injected into the MP.  When an MP's sampling policy dictates
that it should output a measurement, the MP will call the filter's
`output()' function.  The `output()' function computes an output
m-tuple based on all the previous samples, as reflected in its current
internal state.  It must then send the output m-tuple to a writer
object (provided by the OML client library), which either writes the
output sample to file or sends it to the configured OML server.

   Once the output has been written to the data store, the `output()'
function can reset any of its internal state as needed to be ready for
the next set of samples to be injected into the MP.  For instance, an
averaging filter might reset its accumlator and count variables to zero
at this point.

   The final aspect of a filter is the `meta()' function.  This
function is used by OML to construct a schema to describe the filter's
output.  The schema is used by the OML server to construct a database
table to store the filter's output, and is always written out to file
if the filter is configured to output its data to a local file.  The
output description can be used to generate the schema automatically, in
which case the `meta()' function is not required; but if you want to
change the default schema produced from the output description, you can
provide your own meta function.

   TODO: The above might be more enlightening with references to the XML
config format (*note XML configuration::).


File: oml-user-manual.info,  Node: Filter API,  Prev: Anatomy of a filter,  Up: Custom Filters

5.2 Filter API
==============

This section introduces the API for writing filters.  It consists of
two parts:

  1. Utility functions for registering a new filter type and for
     accessing elements of a filter instance; and

  2. Function prototypes and functional descriptions that the
     user-provided filter functions must conform to.

   Both the utility functions and the user-provided function prototypes
definitions are contained in the file `oml_filter.h'.  

   Following this section is a brief tutorial showing how to use this
API in practice.  *Note Filter Tutorial::.

* Menu:

* Utility functions::           Functions for operating on filters.
* Filter function prototypes::  The API that new filters must conform to.
* Filter Tutorial::             A tutorial showing how to define your own filters.


File: oml-user-manual.info,  Node: Utility functions,  Next: Filter function prototypes,  Up: Filter API

5.2.1 Utility functions
-----------------------

 -- Struct: OmlFilter
     Struct representing an instance of a filter.  The OML client
     library creates filter instances during the call to
     `omlc_start()', based on the definitions in the filter factory.
     The `OmlFilter' struct stores the filter instance's private
     instance data, as registered by the `omlf_set_instance_data()'
     function.  All of the filter functions provided by the filter
     writer take an `OmlFilter*' as their first parameter (see *note
     Filter function prototypes::).  The filter writer can use this
     pointer to set and access the instance data, query properties of
     the filter, and perform other necessary operations.  The rest of
     the functions in this section all operate on `OmlFilter' objects.

 -- Struct: OmlFilterDef
     Struct representing the definition of a filter's output, defined as
     follows:

          typedef struct OmlFilterDef
          {
                  const char* name;
                  OmlValueT   type;
          } OmlFilterDef;

     When a new filter type is registered with
     `omlf_register_filter()', the filter output m-tuple must be
     defined as an array of (name, type) pairs, represented using
     `OmlFilterDef'.  The filter designer should create an array of m+1
     `OmlFilterDef' objects specifying the output m-tuple of the
     filter, terminated by a sentinel initialized as `{ NULL, 0 }', and
     pass it to `omlf_register_filter()'.

 -- Function: int omlf_register_filter (
          `const char*' FILTER_NAME,
          `oml_filter_create' CREATE,
          `oml_filter_set' SET,
          `oml_filter_input' INPUT,
          `oml_filter_output' OUTPUT,
          `oml_filter_meta' META,
          `OmlFilterDef*' FILTER_DEF)
     Register a new filter type with the OML client library's internal
     filter factory.

     The filter type is identified by the given NAME.  The NAME can be
     used in the XML configuration file to create instances of this
     type of filter.  Instances of this filter type will be created by a
     call to the given CREATE function.  The OML client library will
     call the given SET, INPUT, OUTPUT and META functions for filter
     instances of type FILTER_NAME.

     This function returns 0 on success and -1 on error.

     The CREATE, INPUT, and OUTPUT functions are required and cannot be
     `NULL'.  If they are `NULL' then the filter type will not be
     registered with the factory and the function will return -1
     (error).

     If the SET parameter is `NULL' then no error is generated and a
     default `set()' function, a no-op, is installed for this filter
     type.

     If the META parameter is `NULL' then a default `meta()' function
     is installed for this filter type.  The default `meta()' function
     inspects the FILTER_DEF and automatically generates the schema
     information from it.

     The FILTER_DEF must point to an array of `OmlFilterDef' structs,
     terminated by a sentinel.  For example, it might look like the
     following:

          OmlFilterDef my_filter_def [] =
          {
                  { "avg", OML_DOUBLE_VALUE },
                  { "min", OML_LONG_VALUE },
                  { "max", OML_LONG_VALUE },
                  { NULL, 0 }
          };

     The FILTER_DEF is also mandatory.  If it is `NULL', an error will
     occur and the function returns -1.  If the type of an entry in the
     FILTER_DEF array is the pseudo-type `OML_INPUT_VALUE', then the
     output type will be set to the type of the filter's primary input.

     The types `oml_filter_create', `oml_filter_set', etc., are
     function pointer types.  They are defined separately in *note
     Filter function prototypes::.

 -- Function: int omlf_set_instance_data (`OmlFilter*' f, `void*'
          instance_data)
     Set the private instance data for filter F.  This function returns
     0 on success and -1 on failure.  The function will fail if the
     filter already has private instance data, or if INSTANCE_DATA is
     `NULL'.

 -- Function: void* omlf_instance_data (`OmlFilter*' f)
     Return the private instance data for filter F, or `NULL' if no
     private data has been registered for this filter yet.

          Implementation note: This function could be implemented as
          either an inline function or a macro for speed.

 -- Function: OmlValue* omlf_create_result_vector (`OmlFilter*' f,
          `OmlValueT*' type, `unsigned int' n)
     Creates a new result vector for filter F, and returns a pointer to
     it.

     If TYPE is `NULL', the result vector is a vector of `OmlValue'
     objects whose types are initialized to match the types specified
     in the filter's output definition, as supplied to
     `omlf_register_filter()'.  Otherwise, TYPE should point to an
     array of length N of `OmlValueT' objects, specifying the type of
     each field in the output m-tuple of the filter.

     The values stored in the vector are initialized to 0 for numeric
     types and `NULL' for pointer types (strings).

     Returns `NULL' on failure.

 -- Function: `OmlValueT' omlf_input_type (`OmlFilter*' f, `int' index)
     Return the type of the filter input with the given INDEX for
     filter F.  If INDEX is not in the range `0..m-1', where `m' is the
     input width (as returned by `omlf_input_width()'), then this call
     will fail with the return value `OML_UNKNOWN_VALUE'.

          Implementation note: This function could be implemented as
          either an inline function or a macro for speed.

 -- Function: int omlf_input_width (`OmlFilter*' f)
     Returns the input width of filter F.  The input width is the
     length of the filter's input tuple.  The input width is calculated
     from the definition of the MP to which this filter is associated.

          Implementation note: This function could be implemented as
          either an inline function or a macro for speed.

 -- Function: int omlf_output_width (`OmlFilter*' f)
     Returns the output width of filter F.  The output width is the
     length of the filter's output tuple.  The output width is
     calculated from the filter definition supplied to
     `omlf_register_filter()'.

          Implementation note: This function could be implemented as
          either an inline function or a macro for speed.

 -- Function: int omlf_write_output (`OmlFilter*' f, `OmlValue*' result)
     Write the RESULT vector for filter F to the data store.  Returns 0
     on success and -1 on failure.

     This function is intended to be called from the filter's
     `output()' function.  Most filters will call this function once
     per invocation of the `output()' function.  However, some filters
     may need to output multiple lines of results, all adhering to the
     filter's output schema, for every call to `output()'.  In this
     case, the filter's `create()' function should call
     `omlf_set_multiline()'.  This will cause the `omlf_write_output()'
     function to emit an epoch on each line of output, and augment the
     schema to match it.

     The epoch is an incrementing counter that starts from 0 and
     increments after each call to the filter's `output()' function.
     Thus, all filter outputs that logically belong to the same
     filtered measurement sample will have the same epoch.

     Note:  the filter definition passed to `omlf_register_filter()'
     does not need to be modified to include the epoch, it will be
     included in the schema automatically.  Even if you supply your own
     `meta()' function, you can write it as normal and the OML client
     library will take care of modifying the schema for multiline
     operation with an epoch included in the schema.

          Implementation note: This function will write output to the
          associated writer object, which will be made available in the
          filter instance's `OmlFilter' struct.

 -- Function: int omlf_set_multiline (`OmlFilter*' f)
     Set the filter F to multiline mode.  In multiline mode, the
     filter's `output()' function can call the `omlf_write_output()'
     function more than once, and the measurement results will be
     augmented with an incrementing epoch that groups all related
     measurement outputs.

     This function must only be called within the filter's `create()'
     function.

     Returns 0 on success, -1 on failure.


File: oml-user-manual.info,  Node: Filter function prototypes,  Next: Filter Tutorial,  Prev: Utility functions,  Up: Filter API

5.2.2 Filter function prototypes
--------------------------------

The core of a user-defined filter is the set of functions it provides
to the OML client library.  This set of functions must conform to the
API expected by OML, which is documented in this section.  You should
write your filter's functions to match the descriptions below.

 -- Function: `typedef int' (*oml_filter_create) (
          `OmlFilter*' f,
          `OmlValueT' type)
     Prototype for every filter's `create()' function.  The create
     function is called when a new instance of this type of filter is
     created.  The OML client library first sets up the `OmlFilter'
     struct for this filter, then calls the `create()' function, so the
     filter is fully constructed (apart from instance data) and in a
     suitable state for all the functions in *note Utility functions::
     to be callable on F.

     The TYPE parameter is the type of the filter's primary input
     value.  The `create()' function can cache this parameter and do
     polymorphic filtering based on the input type, or alternatively it
     can do type checking to ensure that the filter is used only with
     valid input types.

     The create function is responsible for initializing the internal
     state for the new instance of the filter type it belongs to.  Most
     filters would allocate memory for a private instance data
     structure, initialize the structure, and call
     `omlf_set_instance_data()' to register its instance data with the
     `OmlFilter' instance.  It should probably also call
     `omlf_create_result_vector()' to allocate an array to store its
     output.

     For instance, the `create()' function for the built-in averaging
     filter looks something like this:

          typedef struct {
            /* Keep the sum and sample count to calculate average */
            double  sample_sum;
            int     sample_count;

            double  sample_min;
            double  sample_max;

            OmlValue* result;
          } InstanceData;

          int average_create (OmlFilter* f, OmlValueT type)
          {
             /* Validate the input type */
             if (! (type == OML_LONG_VALUE || type == OML_DOUBLE_VALUE))
               return -1;

             /* Allocate private instance data structure */
             InstanceData* self = (InstanceData*)malloc(sizeof(InstanceData));

             if (!self)
               return -1;

             /* Initialize private instance data for computing avg, min, max */
             memset(self, 0, sizeof(InstanceData));
             self->sample_sum = 0;
             self->sample_count = 0;
             self->sample_min = HUGE;
             self->sample_max = -1 * HUGE;

             /* Create the result vector, and save it */
             self->result = omlf_create_result_vector(f, NULL, 0);

             /* Store the private instance data for this filter instance */
             omlf_set_instance_data(f, self);
             return 0;
          }

     If a filter is intended to operating in multiline mode, then its
     `create()' function should call `omlf_set_multiline()'.

     The `create()' function should return 0 on success and -1 on
     failure.  If it signals a failure, then the filter factory will log
     an error to the OML log and the filter instance will not be
     created.  The `create()' function should `free()' and memory it
     allocated before it exits in this case, including any instance data
     set via a call to `omlf_set_instance_data()'.

 -- Function: `typedef int' (*oml_filter_set) (
          `OmlFilter*' f,
          `const char*' name,
          `OmlValue*' value)
     Prototype for every filter's `set()' function.  The `set()'
     function is called by the OML client library to set parameters for
     the filter.  The parameter is specified as having the given NAME
     and VALUE in the XML configuration file (see section XXX).

     It is up to the individual filter to store parameter values, most
     typically in its instance data.  It is free to ignore parameters if
     they are not meaningful for the particular filter type, but its
     `set()' function should return -1 in this case to indicate
     failure.  On success, the `set()' function should return 0.

 -- Function: `typedef int' (*oml_filter_input) (
          `OmlFilter*' f,
          `OmlValue*' primary,
          `OmlValueU*' values)
     Prototype for every filter's `input' function.  The input function
     is called once for every time that the application calls
     `omlc_inject()' on the MP to which the filter instance is
     associated.  This function should update its internal state to
     reflect the new sample data.

     The `input()' function can use `omlf_instance_data(f)' to get
     access to the private instance data of filter F.  Parameter F is
     guaranteed to represent a filter of the correct type.

     The PRIMARY parameter is a pointer to the primary input value for
     this filter, for this input sample.  See this discussion of
     primary input values in section XXX.  Since it is an `OmlValue'
     object, the primary input value is typed and can be validated for
     type checking, or handled differently for different types.

     The VALUES parameter points to the array of input values from the
     MP, i.e. it is the pointer to the MP's input n-tuple for the
     current input sample, where n is the value returned by
     `omlf_input_width()'.

     The VALUES array is an array of `OmlValueU''s, which are untyped.
     This is for efficiency.  The filter can check the types of the
     elements of the VALUES array by making calls to
     `omlf_input_type()'.

     Note that the value of PRIMARY will be present in the VALUES
     array.  The reason for supplying PRIMARY is for convenience.  Many
     filters only require a single input value to filter (for instance,
     the built-in averaging filter).  For such filters, PRIMARY will be
     sufficient and more convenient than indexing the VALUES array; the
     VALUES array can be ignored in that case.  However, some filters
     may need to do computations on multiple elements of the MP's input
     n-tuple, and for these filters the VALUES array is provided.

     The `input()' function should return 0 on success, and -1 to
     indicate a failure.

 -- Function: `typedef int' (*oml_filter_output) (`OmlFilter*' f)
     Prototype for every filter's `output()' function.  The `output()'
     function should perform any finalization of the accumulated filter
     state, store the output values in a result vector, and pass the
     result vector to the `omlf_write_output()' function.

     If the filter is set to use multiline operation, the `output()'
     function can make multiple calls to `omlf_write_output()'.

     The `output()' function should return 0 on success and -1 on
     failure.

 -- Function: `typedef int' (*oml_filter_meta) (
          `OmlFilter*' f,
          `int' index,
          `char**' name_ptr,
          `OmlValueT*' type)
     Prototype for every filter's `meta()' function.  The `meta()'
     function's purpose is to provide the name and type of every
     element of the filter's output m-tuple, so that the OML client
     library can construct a schema for the filter.  The INDEX
     parameter indicates which element of the output m-tuple is being
     queried.  The `meta()' function should set *NAME_PTR to point to a
     string representing the name of the output element, and *TYPE to
     the type of the output element (NAME_PTR and TYPE are
     output-parameters).

     For instance, here is the built-in averaging filter's `meta()'
     function:

          int meta(OmlFilter* f, int index, char** name_ptr, OmlValueT* type)
          {
            if (!f || !name_ptr || !type) return -1;
            if (index > 2) return -1;

            switch (index) {
            case 0:
              *name_ptr = "avg";
              break;
            case 1:
              *name_ptr = "min";
              break;
            case 2:
              *name_ptr = "max";
              break;
            }
            *type = OML_DOUBLE_VALUE;
            return 0;
          }

     The averaging filter's output m-tuple is an array of
     `OML_DOUBLE_VALUE's.  The first element of the output m-tuple is
     called "avg", the second "min", the third "max".

     The `meta()' function should return 0 on success and -1 on
     failure.  In particular, if the INDEX parameter is out of range or
     one of the NAME_PTR or TYPE variables are `NULL', the function
     should fail.


File: oml-user-manual.info,  Node: Filter Tutorial,  Prev: Filter function prototypes,  Up: Filter API

5.2.3 Filter tutorial
---------------------


File: oml-user-manual.info,  Node: Non-instrumented Applications,  Next: Language Bindings,  Prev: Custom Filters,  Up: Top

6 Non-instrumented Applications
*******************************


File: oml-user-manual.info,  Node: Language Bindings,  Next: Measurement Database,  Prev: Non-instrumented Applications,  Up: Top

7 Bindings for other languages
******************************

* Menu:

* Ruby::                        Bindings for Ruby
* Python::                      Bindings for Python


File: oml-user-manual.info,  Node: Ruby,  Next: Python,  Up: Language Bindings

7.1 Ruby
========


File: oml-user-manual.info,  Node: Python,  Prev: Ruby,  Up: Language Bindings

7.2 Python
==========


File: oml-user-manual.info,  Node: Measurement Database,  Next: Server protocol,  Prev: Language Bindings,  Up: Top

8 Measurement Database
**********************


File: oml-user-manual.info,  Node: Server protocol,  Next: Index,  Prev: Measurement Database,  Up: Top

9 Server protocol
*****************

The OML server accepts connections from clients and responds to a custom
protocol.  The protocol is one-way: the client connects to the server
and transmits its measurement data, but the server does not respond to
the client with any control or acknowledgement messages.  Any number of
clients can simultaneously connect to the server (subject to operating
system limits).

   There are two variants of the protocol:  a binary variant and a text
variant.  The client declares the variant of the protocol it wishes to
use when it initiates the connection.  It is possible for multiple
clients to be communicating with the server simultaneously using either
variant.  A client cannot change the protocol variant it is using
during the life of the connection.

   The protocol is divided into two parts:  the client sends a set of
configuration headers in the first part, and then sends its measurement
data in the second part.  The two parts are separated by two consecutive
new line characters (``\n'', 0x0A).  The following grammar describes the
format for the headers:

OML-STREAM       :    OML-HEADERS ``\n'' ``\n'' MEASUREMENT-DATA
OML-HEADERS      :    OML-HEADERS ``\n'' OML-HEADER | OML-HEADER
OML-HEADER       :    HEADER-KEY ``:'' HEADER-VALUE
HEADER-KEY       :    `protocol' |
                      `app-name' |
                      `sender-id' |
                      `experiment-id' |
                      `domain' |
                      `start_time' |
                      `start-time' |
                      `content' |
                      `schema'
MEASUREMENT-DATA :    MEASUREMENT-DATA-BINARY | MEASUREMENT-DATA-TEXT

   It is acceptable for there to be whitespace separating the header key
names and the header values from the delimiter colon (``:'').  The
acceptable values for the headers are shown in the next section,
followed by the formats for the text and binary measurement data.

* Menu:

* Protocol headers::
* Binary measurement data::
* Text measurement data::


File: oml-user-manual.info,  Node: Protocol headers,  Next: Binary measurement data,  Up: Server protocol

9.1 Protocol headers
====================

The majority of the protocol headers are expected to appear only once
in the headers part for each client's data stream.  The exception is
the `schema' header, which can appear multiple times.  If any of the
other headers appear more than once, the server will accept the header
without complaint, but the results will be undefined and may cause
improper behaviour of the server.  Omission of any header except
`app-name' will also result in undefined behaviour.  The `sender-id'
header must follow the `domain' header, otherwise the server will
report an error and drop the connection to the client.

* Menu:

* Protocol::
* app-name::
* sender-id::
* domain::
* experiment-id::
* start_time::
* start-time::
* content::
* schema::


File: oml-user-manual.info,  Node: Protocol,  Next: app-name,  Up: Protocol headers

9.1.1 `protocol'
----------------

The `protocol' header identifies the version of the protocol that the
client is using.  If the server implements a different version of the
protocol, the server will drop the client connection and no
measurements from that client will be stored in the experiment database.

   Currently the supported protocol version is 1.


File: oml-user-manual.info,  Node: app-name,  Next: sender-id,  Prev: Protocol,  Up: Protocol headers

9.1.2 `app-name'
----------------

The `app-name' header is not used and is ignored by the server.


File: oml-user-manual.info,  Node: sender-id,  Next: domain,  Prev: app-name,  Up: Protocol headers

9.1.3 `sender-id'
-----------------

The `sender-id' header is used to identify the client to the server.
The OML client library sends the argument of the `--oml-id' command
line option as the value of this header.


File: oml-user-manual.info,  Node: domain,  Next: experiment-id,  Prev: sender-id,  Up: Protocol headers

9.1.4 `domain'
--------------

The `domain' header names the database in which the client's
measurements should be stored; all measurement data from the same
experiment is stored in a single database.  The OML client library sends
the argument given to the `--oml-domain' command line option as the
value of this header.


File: oml-user-manual.info,  Node: experiment-id,  Next: start_time,  Prev: domain,  Up: Protocol headers

9.1.5 `experiment-id'
---------------------

The `experiment-id' header is a synonym for the `domain' header,
supported for backwards compatibility reasons.


File: oml-user-manual.info,  Node: start_time,  Next: start-time,  Prev: experiment-id,  Up: Protocol headers

9.1.6 `start_time'
------------------

The `start_time' header is a synonym for the `start-time' header,
supported for backwards compatibility reasons.


File: oml-user-manual.info,  Node: start-time,  Next: content,  Prev: start_time,  Up: Protocol headers

9.1.7 `start-time'
------------------

The `start-time' header specifies the client time reference. It should
be an integer that gives the timestamp of client when the client
application started. This is used to synchronize timestamps of all
measurements from all clients in a given experiment. It should be
generated as the `tv_sec' member of the `struct timeval' object
returned by a call to `gettimeofday(2)' on the client.


File: oml-user-manual.info,  Node: content,  Next: schema,  Prev: start-time,  Up: Protocol headers

9.1.8 `content'
---------------

The value of the `content' header may be either `text' or `binary'.
Any other value is an error;  in that case the server will assume text
data, but this should behaviour should be changed to drop the client in
a future version.

   The `content' header determines how the server will interpret the
subsequent measurement data stream.


File: oml-user-manual.info,  Node: schema,  Prev: content,  Up: Protocol headers

9.1.9 `schema'
--------------

The `schema' header specifies the schema for one measurement stream.
There can be multiple measurement streams for each client, and thus
there can be multiple `schema' header lines transmitted by a single
client.

   The `schema' header value consists of a measurement stream (MS)
index, an MS name, and a string of variable:type pairs, colon-separated:

SCHEMA-VALUE:    MS-INDEX MS-NAME FIELD-SPECS
FIELD-SPECS :    FIELD-SPECS FIELD-SPEC | FIELD-SPEC
FIELD-SPEC  :    FIELD-NAME ``:'' FIELD-TYPE
FIELD-TYPE  :    `long' | `double' | `string'

   Valid field names should be alpha-numeric identifiers containing no
spaces; they may contain a hyphen `-' or underscore `_'.

   The MS name is used to identify into which database table to insert
measurements for this client. The MS index is used to associate
subsequent measurement messages with this MS, so that the server knows
which table it should insert each measurement into.  See also...


File: oml-user-manual.info,  Node: Binary measurement data,  Next: Text measurement data,  Prev: Protocol headers,  Up: Server protocol

9.2 Binary measurement data
===========================

If the `content' header is set to `binary' by the client, then the
server will begin interpreting the `measurement-data' as
`measurement-data-binary' for that client.  The binary protocol
consists of a sequence of binary messages, each of each corresponds to
the output of one measurement point/stream on the client,
post-filtering.  Thus, each of the binary messages represents an
m-tuple of measurement values, each of which could have a different
type.  Each binary measurement message follows the same format, which
begins with its own header.

   The message format is shown below:


     Octet#   Datum
     -----------------------------
     0      |  SYNC-BYTE
     1      |  SYNC-BYTE
     2      |  OMB_DATA_P
     3      |  msg-len-H
     4      |  msg-len-L
     5      |  num-measurements
     6      |  ms-index
     -----------------------------
     7      |
     8      |   Typed Binary Values
     9      |
     ...    |      ...

   The `SYNC-BYTE' identifies the start of a binary measurement message
and is equal to 0xAA.  The `OMB_DATA_P' identifies the type of packet,
and is equal to 1.

   The `msg-len-L' and `msg-len-H' together form a 16-bit unsigned
integer, `msg-len' that the client sets equal to the number of octets
in the entire message, less 5; i.e. it is the number of octets
following the `msg-len-L' octet.  This integer is transmitted in
network byte order, and so the `ntohs()' function should be used to
portably read it on a server implementation.

   The `num-measurements' octet specifies the number of measurement
fields in the message, and the `ms-index' identifies the measurement
stream to which this measurement message belongs.  It is the same as
the `ms-index' specified in the `schema' header for this measurement
stream.

   All of the octets following the `ms-index' octet belong to typed
binary value objects.  A typed binary value object is a binary
representation of a numeric or string value sent by the client.  The
first octet of a typed binary value identifies the type of the object.
The interpretation of the following octets of the typed binary value
depend on the type.  The lengths of typed binary value objects vary
depending on the type as well.

   If the first 7 octets up to and including the `ms-index' octet form
the binary message header, then the binary message can be described by
the following grammar:

OML-BINARY-MESSAGE     :    HEADER TYPED-BINARY-VALUES
TYPED-BINARY-VALUES    :    SEQ-NO TIMESTAMP TYPED-BINARY-MEASUREMENTS
TYPED-BINARY-MEASUREMENTS:    TYPED-BINARY-MEASUREMENTS TYPED-BINARY-VALUE
                            |
                            TYPED-BINARY-VALUE
SEQ-NO                 :    TYPED-BINARY-VALUE
TIMESTAMP              :    TYPED-BINARY-VALUE

   The `seq-no' is an incrementing sequence number represented as a
typed binary value object.  The timestamp is a floating point timestamp
that represents the number of seconds between the client's `start-time'
header value and the time when the measurement values in this packet
were captured and sent to the server.  The `typed-binary-measurements'
are the actual application measurement data, and they should be exactly
equal in number to `num-measurements'.

   There are four supported `typed-binary-value' types:
  1. `LONG_T':  32-bit signed long integer values;

  2. `DOUBLE_T':  Double precision floating point values;

  3. `DOUBLE_NAN':  A type representing the floating point
     "Not-a-Number" (NaN) value;

  4. `STRING_T':  A type representing character string values.

* Menu:

* LONG_T type::
* DOUBLE_T type::
* DOUBLE_NAN type::
* STRING_T type::


File: oml-user-manual.info,  Node: LONG_T type,  Next: DOUBLE_T type,  Up: Binary measurement data

9.2.1 `LONG_T'
--------------

The format of the `LONG_T' type is:
     Octet#   Datum
     -----------------------------
     0      |  LONG_T
     1      |  long-byte-3
     2      |  long-byte-2
     3      |  long-byte-1
     4      |  long-byte-0
     -----------------------------

   The value of the first octet is `LONG_T=0x1', which identifies the
type.  The following four octets are the four 8-bit bytes of the 32-bit
long integer, in network byte order.  A portable server implementation
should read this integer back using `ntohl()'.  The octet labelled
`long-byte-3' is the most significant byte, and the byte labelled
`long-byte-0' is the least significant byte.


File: oml-user-manual.info,  Node: DOUBLE_T type,  Next: DOUBLE_NAN type,  Prev: LONG_T type,  Up: Binary measurement data

9.2.2 `DOUBLE_T'
----------------

The format of the `DOUBLE_T' type is:
     Octet#   Datum
     -----------------------------
     0      |  DOUBLE_T
     1      |  mant-byte-3
     2      |  mant-byte-2
     3      |  mant-byte-1
     4      |  mant-byte-0
     5      |  exp
     -----------------------------
   The value of the first octet is `DOUBLE_T=0x2', which identifies the
type.  The following four octets are the four 8-bit bytes of a 32-bit
signed long integer representation of the mantissa of the floating
point value, in network byte order.  A portable server implementation
should read this integer back using `ntohl()'.  Following the mantissa
is the exponent, represented as a signed byte.

   The mantissa word is transmitted in a scaled representation; the
scaling factor is 2^30.  The original floating point value should be
reconstructed using the formula where M is the mantissa and x is the
exponent.


File: oml-user-manual.info,  Node: DOUBLE_NAN type,  Next: STRING_T type,  Prev: DOUBLE_T type,  Up: Binary measurement data

9.2.3 `DOUBLE_NAN'
------------------

The `DOUBLE_NAN' is a pseudo-type that represents the floating point
value Not-a-Number (NaN).  Its format is identical to the `DOUBLE_T'
type, but the first octet is equal to `DOUBLE_NAN=0x3', and the
remaining five octets do not contain any valid data.


File: oml-user-manual.info,  Node: STRING_T type,  Prev: DOUBLE_NAN type,  Up: Binary measurement data

9.2.4 `STRING_T'
----------------

The format of the `STRING_T' type is:
     Octet#   Datum
     -----------------------------
     0      |  STRING_T
     1      |  N
     2      |  str-byte-0
     3      |  str-byte-1
     ...
     N+1    |  str-byte-(N-1)
     -----------------------------
   The value of the first octet is `STRING_T=0x4', which identifies the
type.  The second octet is `N', the length of the string.  The length
of a string is limited to 254 8-bit characters, not including a
null-terminator.  The third and subsequent octets are the string data,
not including any null-terminator.


File: oml-user-manual.info,  Node: Text measurement data,  Prev: Binary measurement data,  Up: Server protocol

9.3 Text measurement data
=========================


File: oml-user-manual.info,  Node: Index,  Prev: Server protocol,  Up: Top

Index
*****

 [index ]
* Menu:

* --oml-collect:                         omlcollect.            (line 6)
* --oml-config:                          omlconfig.             (line 6)
* --oml-domain:                          omldomain.             (line 6)
* --oml-filter-types:                    omllistfilters.        (line 6)
* --oml-help:                            omlhelp.               (line 6)
* --oml-id:                              omlid.                 (line 6)
* --oml-interval:                        omlinterval.           (line 6)
* --oml-log-file:                        omllogfile.            (line 6)
* --oml-log-level:                       omlloglevel.           (line 6)
* --oml-noop:                            omlnoop.               (line 6)
* --oml-samples:                         omlsamples.            (line 6)

 [index ]
* Menu:


Tag Table:
Node: Top173
Node: Introduction3681
Node: What is OML?4994
Ref: What is OML?-Footnote-16258
Node: Organization of this manual6505
Node: Basic concepts of OML7722
Node: Client applications7890
Node: Client configuration8131
Node: Command line8888
Node: omlid11482
Node: omldomain11905
Node: omlcollect12354
Node: omlsamples12825
Node: omlinterval13213
Node: omlconfig13611
Node: omllogfile13858
Node: omlloglevel14329
Node: omlnoop14911
Node: omllistfilters15276
Node: omlhelp15530
Node: XML configuration15736
Node: Root element17244
Node: Data collectors18132
Node: Definining measurement points20576
Node: Defining filters22519
Node: Example XML configuration26084
Node: Configuration errors27710
Node: Server28670
Node: Custom Filters28795
Node: Anatomy of a filter29861
Node: Filter API34219
Node: Utility functions35139
Node: Filter function prototypes43718
Node: Filter Tutorial52510
Node: Non-instrumented Applications52661
Node: Language Bindings52853
Node: Ruby53161
Node: Python53262
Node: Measurement Database53367
Node: Server protocol53533
Node: Protocol headers55676
Node: Protocol56562
Node: app-name57009
Node: sender-id57214
Node: domain57533
Node: experiment-id57963
Node: start_time58230
Node: start-time58496
Node: content59031
Node: schema59503
Node: Binary measurement data60565
Node: LONG_T type64385
Node: DOUBLE_T type65167
Node: DOUBLE_NAN type66222
Node: STRING_T type66645
Node: Text measurement data67359
Node: Index67526

End Tag Table
