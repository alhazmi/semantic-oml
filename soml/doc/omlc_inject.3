'\" t
.\"     Title: omlc_inject
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.76.1 <http://docbook.sf.net/>
.\"      Date: 2015-04-16
.\"    Manual: The OML Manual
.\"    Source: OML 2.12.0pre.79-58cf-dirty
.\"  Language: English
.\"
.TH "OMLC_INJECT" "3" "2015\-04\-16" "OML 2\&.12\&.0pre\&.79\-58cf\-" "The OML Manual"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
omlc_inject \- inject a measurement sample into a measurement point
.SH "SYNOPSIS"
.sp
.nf
\fB#include <oml2/omlc\&.h>\fR
.fi
.sp
.nf
\fIint\fR \fBomlc_inject\fR(\fIOmlMP\fR* mp, \fIOmlValueU\fR* values);
\fIint\fR \fBomlc_inject_metadata\fR(\fIOmlMP\fR* mp, \fIconst char\fR* key, \fIconst OmlValueU\fR* value, \fIOmlValueT\fR type, \fIconst char\fR* fname);
.fi
.SH "DESCRIPTION"
.sp
The main purpose of the \fBliboml\fR(3) is to allow easy reporting of measurement tuples from within instrumented applications\&. This is called \fIinjection\fR\&. A set of \fIMeasurement Points\fR (MPs) are first registered to the library, with a fixed schema describing the tuples to be reported through each MP\&. At run\-time, the injected data is serialised as a \fIMeasurement Stream\fR (MS), and sent towards a collection point\&.
.sp
\fBomlc_inject\fR() takes an array of values and injects them as a measurement sample into an MP previously defined via a call to \fBomlc_add_mp\fR(3)\&. If \fBomlc_inject\fR(3) is called prior to the start of measurement sampling, it will be ignored\&. Measurement sampling is initiated by a call to \fBomlc_start\fR(3)\&.
.SH "METADATA"
.sp
The client library can also inject metadata which doesn\(cqt quite fit in the defined measurement points, or occurs too seldom to justify creating a new one\&. Example metadata includes ancillary information about the application such as version or command line, or some specific details about MPs or specific fields such as precision and units\&. Metadata is sent along a specific MS named \fI_experiment_metadata\fR\&. Metadata information consists of \fIkey\fR/\fIvalue\fR pairs qualifying a \fIsubject\fR\&. The subject is a string formatted as \fI\&.[mpname[\&.fname]]\fR, where \fI\&.\fR identifies the root of the application, and additional components allow to specify the entity to which the metadata refers more precisely\&.
.sp
Metadata can be injected from the client side using the \fBomlc_inject_metadata\fR() function\&. The \fIsubject\fR is derived from \fImp\fR (which can be \fINULL\fR) and that MP\(cqs optional field \fIfname\fR (which is ignored if \fImp\fR is \fINULL\fR)\&. The \fIkey\fR is specified as a nil\-terminated C\-string, and the \fIvalue\fR as an \fBOmlValueU\fR(3), allowing some type flexibility\&. At the moment, the only valid \fItype\fR for \fIvalue\fR is \fIOML_STRING_VALUE\fR; anything else will generate an error\&. Nonetheless it needs to be properly initialised (\fBomlc_zero\fR(3)) and cleaned up (\fBomlc_reset_string\fR(3))\&.
.SH "AN IMPORTANT NOTE ON THE GOODNESS OF GENERATED CODE"
.sp
Prior to reading the following, it is worthy to note that \fBoml-scaffold\fR(1) can be used to generate custom registration and injection helpers from a high\-level description of an application\(cqs MPs\&. This is sufficient for most applications, and avoids errors in manipulating low\-level data structures\&. This also provides some abstraction from occasional API changes, and simplifies porting to newer versions of OML\&. It is therefore the recommended approach for all applications with static measurement points (i\&.e\&., not created dynamically with variable MPs depending on run\-time conditions, such as specific instrumented plugin code)\&.
.sp
The code generated by \fBoml-scaffold\fR(1) follows the structure described thereafter\&. The registration helpers create the \fIOmlMPDef\fR structures as exemplified below, and rely on \fBomlc_add_mp\fR(3) to register the MPs on behalf of the user (in \fBoml_register_mps\fR(3))\&. The injection helpers (see \fBoml_inject_MPNAME\fR(3)) offer C\-functions with typed argument, and map them internally to \fIOmlValueU\fR before calling \fBomlc_inject\fR()\&.
.SH "MANUALLY INJECTING SAMPLES"
.sp
In some cases (mostly when defining MPs dynamically at run time), it is not possible to use injection helpers (see previous section)\&. Only in these cases is it justified to use \fIomlc_inject\fR directly\&. This is described here\&.
.sp
The \fImp\fR parameter must be an MP handle returned by a call to \fBomlc_add_mp\fR(3)\&. The \fIvalues\fR array must contain values whose number and types correspond to the types declared for the MP tuple in the call to \fBomlc_add_mp\fR(3)\&. The convenience macros \fBomlc_set_\fR*() should be used to set up the values array\&.
.sp
For instance, suppose the following MP definition:
.sp
.if n \{\
.RS 4
.\}
.nf
OmlMPDef mp_def [] =
{
  { "source", OML_UINT32_VALUE },
  { "destination", OML_UINT32_VALUE },
  { "length", OML_UINT32_VALUE },
  { "weight", OML_DOUBLE_VALUE },
  { "protocol", OML_STRING_VALUE },
  { "txrates", OML_VECTOR_UINT32_VALUE },
  { NULL, (OmlValueT)0 } /* Sentinel value */
};
.fi
.if n \{\
.RE
.\}
.sp
(See \fBomlc_add_mp\fR(3) for details\&.)
.sp
To inject a measurement sample into this MP, the programmer must first declare an \fIOmlValueU\fR array with the right number of elements, in this case six (the sentinel value is only needed when declaring the MP to \fBomlc_add_mp\fR(3), it doesn\(cqt play any further part)\&. Then, call the value setting macros to load new values into the array, and finally pass the array to \fBomlc_inject\fR():
.sp
.if n \{\
.RS 4
.\}
.nf
OmlMP *mp = omlc_add_mp ("myMP", mp_def);

\&.\&.\&.

omlc_start();

\&.\&.\&.

uint32_t source_id;
uint32_t destination_id;
uint32_t packet_length;
double weight;
char *protocol;
double txrates[16];
size_t txrates_sz = sizeof(txrates) / sizeof(txrates[0]);

/* Some application\-specific code to obtain new values for the variables above */

\&.\&.\&.

OmlValueU values[6];

omlc_zero_array(values, 6);

omlc_set_uint32 (values[0], source_id);
omlc_set_uint32 (values[1], destination_id);
omlc_set_uint32 (values[2], packet_length);
omlc_set_double (values[3], weight);
omlc_set_string (values[4], protocol);
omlc_set_vector_double (values[5], txrates, txrates_sz);

omlc_inject (mp, values);

omlc_reset_vector(values[5]);
omlc_reset_string(values[4]);
.fi
.if n \{\
.RE
.\}
.sp
Internally, the library guards each MP with a mutex, so this function should be thread safe\&.
.sp
The caller must be careful to ensure that the \fIvalues\fR array has enough elements to accommodate the declared number of fields in the tuple for the given \fImp\fR\&. Otherwise, \fBomlc_inject\fR() might try to read past the end of the array\&. Similarly, the types of the values must be as declared, and in the same order in the array as specified for the MP tuple definition\&. This is particularly important for strings\&.
.sp
The values array should be considered "write\-only" and should only be manipulated using the value\-setting macros, see \fBOmlValueU\fR(3) for information on supported data types and there accessors\&.
.sp
Once a call to \fBomlc_inject\fR() has been made, it is safe to modify/free the values vector, as \fBomlc_inject\fR() creates internal copies\&.
.SH "RETURN VALUE"
.sp
These functions return 0 on success, or a negative value on error\&.
.sp
This is particularly the case if the library has not been initialized with a call to \fBomlc_init\fR(3), or if measurement sampling has not been started with a call to \fBomlc_start\fR(3)\&. It this case the function exits, without performing any actions, with status \-1\&. Similarly, if either \fImp\fR or \fIvalues\fR is NULL, then the function exits with the same status\&.
.SH "BUGS"
.sp
If a problem you are experiencing is not addressed in the FAQ (http://oml\&.mytestbed\&.net/projects/oml/wiki/FAQ_and_Support) nor already present in the list of know bugs (http://oml\&.mytestbed\&.net/projects/oml/issues)\&. You could discuss it on the mailing list (details and archives at http://oml\&.mytestbed\&.net/tab/show?id=oml)\&.
.sp
It is however advisable to open a ticket on our issue tracker at http://oml\&.mytestbed\&.net/projects/oml/issues/new\&. Don\(cqt forget to include details such as client and server logs (at \fI[\-\-oml\-log\-level|\-d] 2\fR)\&. It also helps if you can share the source code of a (minimal, if possible) example reliably triggering the problem\&.
.SH "SEE ALSO"
.SS "Manual Pages"
.sp
\fBoml2-server\fR(1), \fBliboml2\fR(1), \fBliboml2\fR(3), \fBliboml2.conf\fR(5)
.sp
\fBomlc_init\fR(3), \fBomlc_add_mp\fR(3), \fBomlc_start\fR(3), \fBOmlValue\fR(3)
.SS "OML User Manual"
.sp
http://oml\&.mytestbed\&.net/projects/oml/wiki/Documentation
