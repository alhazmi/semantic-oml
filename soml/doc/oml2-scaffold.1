'\" t
.\"     Title: oml2-scaffold
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.76.1 <http://docbook.sf.net/>
.\"      Date: 2015-04-16
.\"    Manual: The OML Manual
.\"    Source: OML 2.12.0pre.79-58cf-dirty
.\"  Language: English
.\"
.TH "OML2\-SCAFFOLD" "1" "2015\-04\-16" "OML 2\&.12\&.0pre\&.79\-58cf\-" "The OML Manual"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
oml2-scaffold \- OML2 instrumentation code generator
.SH "SYNOPSIS"
.sp
.nf
\fBoml2\-scaffold\fR [OPTIONS] [\-\-oml|\-\-opts|\-\-main|\-\-make] \fIappfile\fR
\fBoml2\-scaffold\fR [OPTIONS] \-\-app \fIappname\fR
.fi
.SH "DESCRIPTION"
.sp
\fBoml2\-scaffold\fR generates skeleton OML application source code based on a template provided by the user (the file named \fIappfile\fR)\&. When invoked with the \fB\-\-oml\fR options, a C header is generated describing the application\(cqs OML measurement points and providing helper functions based on \fBomlc_inject\fR(3) for each of them; when \fB\-\-opts\fR is used, another C header is generated that describes the command line options that the program accepts, using the functions and data structures provided by the \fBpopt\fR(3) library; when \fB\-\-main\fR is used, a C file is generated that provides a skeleton \fBmain\fR() function and run loop, with an example of how to inject measurement samples using the helpers functions defined in the header for every defined measurement point; and when \fB\-\-make\fR is used, \fBoml2\-scaffold\fR creates a Makefile that can be used to build the generated program\&.
.sp
In fact, the generated program can be built and run as\-is with no further modifications required\&. This can serve as an example OML application to play with, however the data that it measures is not very interesting\&. The programmer must supply that part of the application, unfortunately\&.
.SH "OPTIONS"
.sp
\fBoml2\-scaffold\fR recognises the following command line options:
.PP
\-\-oml
.RS 4
Create OML header file
\fIAPPNAME_oml\&.h\fR
defining all measurement points, as well as registration and injection helper functions (\fBoml_register_mps\fR(3)
and
\fBoml_inject_MPNAME\fR(3))\&. The registration helper is only available when defining
\fBcpp\fR(1)
macro
\fIOML_FROM_MAIN\fR
prior to the
\fI#include\fR
statement for
\fIAPPNAME_oml\&.h\fR\&. This should only be done in the file calling
\fBoml_register_mps\fR(3)
(usually in the
\fBmain\fR() function)\&.
.RE
.PP
\-\-opts
.RS 4
Create the
\fBpopt\fR(3)
header file
\fIAPPNAME_popt\&.h\fR
for application command\-line parsing\&.
.RE
.PP
\-\-make
.RS 4
Create a skeleton Makefile for this application\&.
.RE
.PP
\-\-main
.RS 4
Create skeleton main file
\fIAPPNAME\&.c\fR
for this application\&.
.RE
.PP
\-a, \-\-app \fIname\fR
.RS 4
Create a skeleton application definition file
\fIname\&.rb\fR
for an application with the given
\fIname\fR\&. Other files generated from this application definition will use
\fIname\fR
as
\fIAPPNAME\fR\&.
.RE
.PP
\-f, \-\-force
.RS 4
Do not check if a file would be overwritten\&. Otherwise
\fBoml2\-scaffold\fR
checks for an existing file before trying to write to it, and aborts if it already exists\&.
.RE
.PP
\-l, \-\-long
.RS 4
Use the
\fI:long\fR
type as the underlying type for the
\fI:int\fR
and
\fI:integer\fR
aliases\&. This overrides the default of
\fI:int32\fR
.RE
.PP
\-i, \-\-int32
.RS 4
Use the
\fI:int32\fR
type as the underlying type for the
\fI:int\fR,
\fI:integer\fR
and
\fI:long\fR
aliases\&. This is the default behaviour\&.
.RE
.PP
\-v, \-\-version
.RS 4
Print the version number of
\fBoml2\-scaffold\fR\&.
.RE
.PP
\-h, \-\-help
.RS 4
Print a brief usage message\&.
.RE
.sp
It is permitted to issue multiple of \fB\-\-oml\fR, \fB\-\-opts\fR, \fB\-\-main\fR, and \fB\-\-make\fR on the same command line\&.
.SH "TEMPLATE LANGUAGE"
.sp
The template language is based on Ruby syntax\&. Here is a simple example:
.sp
.if n \{\
.RS 4
.\}
.nf
defApplication(\*(Aqoml:man:foo\*(Aq, \*(Aqfoo\*(Aq) do |app|
  app\&.version(1,0)
  app\&.shortDescription = "Monitoring the system\*(Aqs foo"
  app\&.description = %{
\*(Aqfoo\*(Aq is an application to measure the \*(Aqfoo\*(Aq of a network and
its computers\&. }
  app\&.path = "/PATH/TO/BINARY"

  app\&.defProperty(\*(Aqcpu\*(Aq, \*(AqReport CPU foo\*(Aq, \*(Aq\-c\*(Aq,
               :type => :boolean, :var_name => \*(Aqreport_cpu\*(Aq)
  app\&.defProperty(\*(Aqmem\*(Aq, \*(AqReport memory foo\*(Aq, "\-\-mem",
               :type => :boolean, :unit => "bytes",
               :mnemonic => \*(Aqm\*(Aq,
               :var_name => \*(Aqreport_memory\*(Aq)

  app\&.defMeasurement("memory") do |mp|
    mp\&.defMetric(\*(Aqram\*(Aq, :string)
    mp\&.defMetric(\*(Aqtotal\*(Aq, :uint32)
    mp\&.defMetric(\*(Aqfree\*(Aq, :uint32)
    mp\&.defMetric(\*(Aqused\*(Aq, :uint32)
    mp\&.defMetric(\*(Aqfree_percent\*(Aq, :double)
    mp\&.defMetric(\*(Aqused_percent\*(Aq, :double)
  end

  app\&.defMeasurement("cpu") do |mp|
    mp\&.defMetric(\*(Aquser\*(Aq, :uint64)
    mp\&.defMetric(\*(Aqsys\*(Aq, :uint64)
    mp\&.defMetric(\*(Aqnice\*(Aq, :uint64)
    mp\&.defMetric(\*(Aqidle\*(Aq, :uint64)
    mp\&.defMetric(\*(Aqwait\*(Aq, :uint64)
    mp\&.defMetric(\*(Aqirq\*(Aq, :uint64)
    mp\&.defMetric(\*(Aqsoft_irq\*(Aq, :uint64)
    mp\&.defMetric(\*(Aqstolen\*(Aq, :uint64)
    mp\&.defMetric(\*(Aqtotal\*(Aq, :uint64)
  end
end
.fi
.if n \{\
.RE
.\}
.sp
The \fIdefApplication\fR command begins the template, and it takes two arguments: a \fIuri\fR and a \fIname\fR\&. It also takes a Ruby block that can create the features of the application\&. The \fIuri\fR must be a string containing a colon\-separated set of components\&. The \fIuri\fR is mandatory, but the \fIname\fR is optional\&. If the \fIname\fR is not supplied then it is taken from the final component of the \fIuri\fR\&. For example,
.sp
.if n \{\
.RS 4
.\}
.nf
defApplication(\*(Aqoml:man:bar\*(Aq) do |a|
\&.\&.\&.
end
.fi
.if n \{\
.RE
.\}
.sp
will create an application named \fIbar\fR\&. The application name is used to name the files that \fBoml2\-scaffold\fR generates\&. Note that \fIdefApplication\fR must be followed by a block in either of Ruby\(cqs two syntaxes for blocks, either using do\&...end as above, or the C\-like curly brace syntax:
.sp
.if n \{\
.RS 4
.\}
.nf
defApplication(\*(Aqoml:man:bar\*(Aq) { |a|
\&.\&.\&.
}
.fi
.if n \{\
.RE
.\}
.sp
The \fIdefApplication\fR block is given an application object as a parameter (that\(cqs the do |a| part)\&. The application object supports a number of operations that are described below\&.
.SS "app\&.version(major, minor = 0, revision = 0)"
.sp
The \fIversion\fR command specifies the application\(cqs version number\&. The \fIminor\fR and \fIrevision\fR can be omitted\&. The arguments are assumed to be integers\&. The version information is output as a string in the file \fIversion\&.h\fR\&. As an example, the following version declaration:
.sp
.if n \{\
.RS 4
.\}
.nf
app\&.version(2, 4, 0)
.fi
.if n \{\
.RE
.\}
.sp
will result in a \fIversion\&.h\fR file containing the following C preprocessor #define:
.sp
.if n \{\
.RS 4
.\}
.nf
#define VERSION "2\&.4\&.0"
.fi
.if n \{\
.RE
.\}
.SS "app\&.shortDescription = <string>"
.sp
This should be a one\-line description of the application\&.
.SS "app\&.description = <string>"
.sp
This should be a longer description of the application\&. It can use Ruby\(cqs multi\-line string syntaxes to allow a string that breaks over multiple lines, as in the example above\&.
.SS "app\&.path = <string>"
.sp
This is the path where the application is expected to be installed\&. This is particularly useful when generationg the Makefile with the \fB\-\-make\fR option\&. OMF also uses this information\&.
.SS "app\&.defProperty(name, description, parameter, options = {})"
.sp
The \fIdefProperty\fR command provides a way to describe the options that the program accepts on the command line\&. The code generated by the \fB\-\-opts\fR option to \fBoml2\-scaffold\fR uses the \fIdefProperty\fR commands to construct a \fBpopt\fR(3) table and function to parse the options that they define\&.
.sp
The \fIname\fR parameter identifies the option\&.
.sp
The \fIdescription\fR parameter is used by \fBpopt\fR(3) when generating the help message for the \fB\-\-help\fR option (\fIdescrip\fR)\&.
.sp
The \fIparameter\fR is the string that needs to be added before introducing the option\&. It can be either a short of a long option depending on how many dashes prefix it\&.
.PP
One dash
.RS 4

\fI\-\fR
identifies a single\-letter parameter\&. The following character will be used as the
\fIshortName\fR
by
\fBpopt\fR(3)
(in this case,
\fIlongName\fR
is taken to be
\fIname\fR)\&.
.RE
.PP
Two dashes
.RS 4

\fB\-\-\fR
identifies a long option\&. The following string will be used as the
\fIlongName\fR
by
\fBpopt\fR(3)
(in this case,
\fIshortName\fR
is taken to be the same as
\fI:mnemonic\fR
below, or nothing)\&.
.RE
.sp
The \fIoptions\fR parameter should be a Ruby hash, but can be introduced straight after the above options\&. It allows the user to describe further behaviour for the option\&. The possible keys are as follows\&.
.PP
\fB:type\fR
.RS 4
The
\fI:type\fR
option specifies what type of argument this option accepts\&. If
\fI:type\fR
is omitted then
\fI:int\fR
is assumed\&. The
\fI:type\fR
option should be one of:
.PP
\fI:boolean\fR
.RS 4
This property is a flag that can be represented as a boolean value; it does not require an argument\&. For instance, a
\fI\-q\fR
option for enabling a quiet mode of operation could use the
\fI:boolean\fR
option\&.
\fI:flag\fR
is a deprecated OMF\-incompatible synonym\&.
.RE
.PP
\fI:string\fR
.RS 4
This property accepts a string argument\&.
.RE
.PP
\fI:int\fR, \fI:integer\fR, \fI:long\fR, \fI:long_long\fR
.RS 4
This property accepts an integer argument that is either a C
\fIint\fR, a C
\fIlong\fR, or a C
\fIlong long\fR
value\&. The
\fI:integer\fR
variant is a synonym for
\fI:int\fR\&.
.RE
.PP
\fI:double\fR, \fI:float\fR
.RS 4
This property accepts a floating point argument that is either a C
\fIdouble\fR
or a C
\fIfloat\fR\&. When in doubt, prefer
\fIdouble\fR\&.
.RE
.RE
.PP
\fB:mnemonic\fR
.RS 4
A character which is returned by
\fBpopt\fR(3)\fIs \*(AqpoptGetNextOpt\fR
when this option is found\&. When
\fIparameter\fR
starts with two dashes, the
\fB:mnemonic\fR
is also used as the
\fIshortName\fR\&.
.RE
.PP
\fB:unit\fR
.RS 4
The unit for this property\&. This is used by
\fBpopt\fR(3)
when generating the help message for the
\fB\-\-help\fR
option (\fIargDescrip\fR)\&.
.RE
.PP
\fB:default\fR
.RS 4
A default value for this property if it is not specified on the command line by the user of the application\&.
.RE
.PP
\fB:var_name\fR
.RS 4
Used to name the C variable that will store the value of this command line option\(cqs argument\&. Otherwise a sanitised version of the
\fIname\fR
is used\&. The option arguments are all stored in variables within the
\fIg_opts_storage\fR
struct in the generated C program\&.
.RE
.SS "app\&.defMeasurement(name)"
.sp
The \fIdefMeasurement\fR command defines a new, named measurement point\&. (For more information about what a measurement point is, see \fBliboml2\fR(1) and \fBliboml2\fR(3)\&.) The command accepts a block that takes a single parameter, the MP itself; this block is used to define the fields of the measurement point\&. Each field is defined using the \fIdefMetric\fR command\&.
.SS "mp\&.defMetric(name, type)"
.sp
\fIdefMetric\fR defines a single field of a measurement point\&. Each field must have a \fIname\fR and a \fItype\fR\&. The \fItype\fR must be a string equal to one of the following, which correspond with the defined OML types:
.PP
\fB:int32\fR
.RS 4
This field will record 32\-bit signed integer data\&.
\fI:long\fR
is a deprecated synonym\&.
\fI:int\fR
and
\fI:integer\fR
also map to this type, but their use is not recommended\&.
.RE
.PP
\fB:uint32\fR
.RS 4
This field will record 32\-bit unsigned integer data\&.
.RE
.PP
\fB:int64\fR
.RS 4
This field will record 64\-bit signed integer data\&.
.RE
.PP
\fB:uint64\fR
.RS 4
This field will record 64\-bit unsigned integer data\&.
.RE
.PP
\fB:double\fR
.RS 4
This field will record floating point data in C
\fIdouble\fR
format\&.
\fI:float\fR
and
\fI:real\fR
are deprecated synonyms\&.
.RE
.PP
\fB:string\fR
.RS 4
This field will record string data\&.
.RE
.PP
\fB:blob\fR
.RS 4
This field will record binary data\&.
.RE
.PP
\fB:guid\fR
.RS 4
This field will record a globally unique identifier allowing to group tuples together, or to link them accross
\fIMPs\fR\&. See
\fBomlc_guid_generate\fR(3)
for more details\&.
.RE
.PP
\fB:boolean\fR
.RS 4
This field will record a boolean value\&.
.RE
.PP
\fB:vector_int32\fR
.RS 4
This field will hold a vector of 32\-bit signed integer values\&.
.RE
.PP
\fB:vector_uint32\fR
.RS 4
This field will hold a vector of 32\-bit unsigned integer values\&.
.RE
.PP
\fB:vector_int64\fR
.RS 4
This field will hold a vector of 64\-bit signed integer values\&.
.RE
.PP
\fB:vector_uint64\fR
.RS 4
This field will hold a vector of 64\-bit unsigned integer values\&.
.RE
.PP
\fB:vector_double\fR
.RS 4
This field will hold a vector of C
\fIdouble\fR
values\&.
.RE
.PP
\fB:vector_bool\fR
.RS 4
This field will hold a vector of C
\fIbool\fR
values\&.
.RE
.sp
The integer types \fI:int32\fR, \fI:uint32\fR \fI:int64\fR, and \fI:uint64\fR are implemented in the application as the corresponding types from \fBstdint\&.h\fR, namely \fIint32_t\fR, \fIuint32_t\fR, \fIint64_t\fR, and \fIuint64_t\fR respectively\&.
.sp
The \fIdefMetric\fR command also recognizes the type \fI:long\fR, which corresponds to the C \fIlong\fR type\&. However, this type is deprecated because \fIlong\fR changes size between 32\-bit and 64\-bit platforms\&. New programs should use one of \fI:int32\fR or \fI:int64\fR instead\&. See the \fBOML TYPES\fR section of the \fBliboml2\fR(3) man page for more information\&.
.sp
The types \fI:float\fR and \fI:real\fR are synonyms for the type \fI:double\fR\&. In OML v2\&.5 and earlier, the types \fI:int\fR and \fI:integer\fR were synonyms for \fI:long\fR\&. Because \fI:long\fR is deprecated, these aliases are now mapped to \fI:int32\fR from OML 2\&.6 and onwards\&. To give developers a chance to migrate their applications, we provide switches \fB\-\-int32\fR and \fB\-\-long\fR\&. Each one selects what the underlying type will be for the \fI:int\fR and \fI:integer\fR aliases\&. In OML 2\&.5, the default behaviour if neither was specified was \fI:long\fR, which could be overridden with the \-\-int32 switch\&. In OML 2\&.6 and later the default is for \fI:int\fR and \fI:integer\fR to map to \fI:int32\fR, which developers can override using the \fB\-\-long\fR switch\&.
.sp
It is also permissible to use strings to specify the type of a metric, i\&.e\&., \fI"int32"\fR instead of \fI:int32\fR, \fI"double"\fR instead of \fI:double\fR\&.
.SH "BUT I DON\(cqT KNOW RUBY!"
.sp
Although the template language uses Ruby syntax, you shouldn\(cqt need to know Ruby in order to define applications using \fBoml2\-scaffold\fR\&. All of the most useful features of the template language are illustrated in the example above\&. It should be sufficient to copy and paste the example and then modify it to suit your own needs\&. Two things are worth mentioning about Ruby syntax:
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
Ruby strings can use either single quotes \*(Aqfoo\*(Aq, double quotes "bar", or any of several multi\-line syntaxes\&. The main difference between the first two is in their behaviour when interpolating values from Ruby variables, but this is not required for most purposes when using
\fBoml2\-scaffold\fR\&. The multi\-line string syntaxes in Ruby are even more esoteric; the one used above should be sufficient\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
Ruby hash table literals are introduced using curly braces:
.sp
.if n \{\
.RS 4
.\}
.nf
myhash = { \*(Aqa\*(Aq => 1, \*(Aqb\*(Aq => 2 }
.fi
.if n \{\
.RE
.\}
.sp
This example constructs a hash in which the key \*(Aqa\*(Aq maps to the value 1, and the key \*(Aqb\*(Aq maps to the value 2\&. Each key\-value pair is separated by a comma\&.
.sp
Ruby has a special rule for hashes that appear as arguments in a method call: you can omit the curly braces on a literal hash that appears as the final argument in a method call\&. This means that the following two are equivalent:
.sp
.if n \{\
.RS 4
.\}
.nf
myobj1\&.foo(42, "hello", { \*(Aqa\*(Aq => 1, \*(Aqb\*(Aq => 2 })

myobj1\&.foo(42, "hello", \*(Aqa\*(Aq => 1, \*(Aqb\*(Aq => 2)
.fi
.if n \{\
.RE
.\}
.sp
The example application definition given above uses the second syntax\&. However, if one of the values of the hash is itself a hash, then you have to include the curly braces on the value hash:
.sp
.if n \{\
.RS 4
.\}
.nf
myobj1\&.foo(42, "hello", \*(Aqa\*(Aq => 1, \*(Aqb\*(Aq => { :var_name => \*(Aqreport_cpu\*(Aq })
.fi
.if n \{\
.RE
.\}
.RE
.sp
If you do want to find out more about Ruby syntax, there are many good tutorials on the Internet\&. This one is a good starting point:
.sp
.if n \{\
.RS 4
.\}
.nf
http://www\&.ruby\-lang\&.org/en/documentation/quickstart/
.fi
.if n \{\
.RE
.\}
.SH "RESTRICTIONS ON NAMES"
.sp
The application name, the measurement point names (\fIdefMeasurement\fR), and the measurement point field names (\fIdefMetric\fR) should be constrained to alpha\-numeric names with a leading underscore or letter\&. This is because they can appear in the names of tables and columns in the databases generated by the OML server, and therefore both the client library and the server reject names that are not easily used as SQL table and column names\&.
.sp
\fBoml2\-scaffold\fR currently does not impose any restrictions on names, but a future version probably will\&.
.SH "URI FORMAT"
.sp
The \fIdefApplication\fR command accepts a \fIuri\fR parameter as documented above\&. The URI can be chosen according to user needs, and does not have to start with \*(Aqomf:app\*(Aq as in the example above\&. When using the \fB\-\-app\fR option to generate a skeleton application definition, \fBoml2\-scaffold\fR will use the environment variable \fBUSER\fR as the first component of the uri, and \*(Aqapp\*(Aq as the second, so for a user named bob, the following command line will result in an application with a uri of \*(Aqbob:app:foo\*(Aq:
.sp
.if n \{\
.RS 4
.\}
.nf
$ oml2\-scaffold \-\-app foo
.fi
.if n \{\
.RE
.\}
.SH "FILES"
.sp
The \fBoml2\-scaffold\fR program generates a single output file for each possible command\&. The files generated are named as follows:
.PP
\-\-oml
.RS 4
.PP
<app\-name>_oml\&.h
.RS 4
The header defining the OML measurement points and helper functions\&.
.RE
.RE
.PP
\-\-opts
.RS 4
.PP
<app\-name>_popt\&.h
.RS 4
The header file defining the command line options for
\fBpopt\fR(3)
.RE
.RE
.PP
\-\-main
.RS 4
.PP
<app\-name>\&.c
.RS 4
The main C header file;
.RE
.PP
version\&.h
.RS 4
A file defining version information for the application\&.
.RE
.RE
.PP
\-\-make
.RS 4
.PP
Makefile
.RS 4
A Makefile for building the program with
\fBmake\fR(1)\&.
.RE
.RE
.PP
\-\-app <app\-name>
.RS 4
.PP
<app\-name>\&.rb
.RS 4
A skeleton application definition file\&.
.RE
.RE
.SH "NOTES"
.sp
This program used to be called \fIoml2_scaffold\fR (with an underscore)\&. It was renamed to be more consistent with the other OML binaries, which use the prefix \fIoml2\-\fR (with a hyphen)\&. The installation process installs a link from \fIoml2_scaffold\fR to \fIoml2\-scaffold\fR so as not to break old scripts, but users should use the new name for new scripts, and should try to migrate their old scripts to use the new name over time\&.
.SH "BUGS"
.sp
If a problem you are experiencing is not addressed in the FAQ (http://oml\&.mytestbed\&.net/projects/oml/wiki/FAQ_and_Support) nor already present in the list of know bugs (http://oml\&.mytestbed\&.net/projects/oml/issues)\&. You could discuss it on the mailing list (details and archives at http://oml\&.mytestbed\&.net/tab/show?id=oml)\&.
.sp
It is however advisable to open a ticket on our issue tracker at http://oml\&.mytestbed\&.net/projects/oml/issues/new\&. Don\(cqt forget to include details such as client and server logs (at \fI[\-\-oml\-log\-level|\-d] 2\fR)\&. It also helps if you can share the source code of a (minimal, if possible) example reliably triggering the problem\&.
.SH "SEE ALSO"
.SS "Manual Pages"
.sp
\fBoml2-server\fR(1), \fBliboml2\fR(1), \fBliboml2\fR(3), \fBliboml2.conf\fR(5), \fBomlc_inject\fR(3)
.sp
\fBpopt\fR(3)
.SS "OML User Manual"
.sp
http://oml\&.mytestbed\&.net/projects/oml/wiki/Documentation
.SS "Ruby"
.sp
http://www\&.ruby\-lang\&.org
