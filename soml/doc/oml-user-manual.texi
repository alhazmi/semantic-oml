\input texinfo @c -*- texinfo -*-
@c %**start of header
@setfilename oml-user-manual.info
@settitle OML User Manual
@c %**end of header

@copying
Copyright @copyright{} 2009-2014, NICTA

Locked Bag 9013 @*
Alexandria NSW 1430 @*
AUSTRALIA @*
@end copying

@titlepage
@title OML User Manual
@subtitle OML -- The OMF Measurement Library
@subtitle For version 2.4.0, 1 October 2009
@author Jolyon White

@c The following two commands start the copyright page
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage



@c Output the table of contents at the beginning
@contents

@ifnottex
@node Top
@top OML User Manual

This manual is for OML, The OMF Measurement Library, version 2.3.0, a
package containing a software framework for distributed measurement
collection in network testbeds or clustered simulation experiments.

OMF is the cOntrol and Management Framework for maintaining network
testbeds and running distributed networking experiments on network
testbeds.  You can find out more about OMF at:

@indicateurl{http://www.mytestbed.net}

The core of OML consists of a measurement server and a client library.
Users of OML can write applications that use the functions of the
client library to record measurements from an experiment running on
one network host, and either write them to a file locally on that
host, or send them to the server over a network connection.  The
server can record results of multiple experiments running
simultaneously on multiple network hosts, and writes them to a
database on the machine hosting the server.  It is even possible to
run experiments on network hosts that are sometimes disconnected,
using the OML proxy server.



@end ifnottex
@menu
* Introduction::                Introduction to OML.
* Basic concepts of OML::
* Client applications::
* Server::                      Using the OML server and the OML proxy server.
* Custom Filters::              How to design custom filters for use with OML.
* Non-instrumented Applications::  How to use OML with third party programs when you don't have source code.
* Language Bindings::           Bindings for languages other than C/C++.
* Measurement Database::        Querying the measurement database.


* Server protocol::
* Index::                       Index.

@detailmenu
 --- The Detailed Node Listing ---

Introduction

* What is OML?::
* Organization of this manual::

Client application

* Client configuration::        How to configure an OML client application

Client configuration

* Command line::                Configuring the OML client from the command line
* XML configuration::           Configuring the OML client using an XML file
* Configuration errors::        What happens if you make a mistake configuring OML

Command line

* omlid::
* omldomain::
* omlcollect::
* omlsamples::
* omlinterval::
* omlconfig::
* omllogfile::
* omlloglevel::
* omlnoop::
* omllistfilters::
* omlhelp::

XML configuration

* Root element::                The root element of the XML file.
* Data collectors::
* Definining measurement points::  How to define what measurements to collect.
* Defining filters::            How to create filters on each MP.
* Example XML configuration::

Custom Filters

* Anatomy of a filter::         The basic components of an OML filter.
* Filter API::                  The interface for filter writers.

Filter API

* Utility functions::           Functions for operating on filters.
* Filter function prototypes::  The API that new filters must conform to.
* Filter Tutorial::             A tutorial showing how to define your own filters.

Bindings for other languages

* Ruby::                        Bindings for Ruby
* Python::                      Bindings for Python

Server protocol

* Protocol headers::
* Binary measurement data::
* Text measurement data::

Protocol headers

* Protocol::
* app-name::
* sender-id::
* domain::
* experiment-id::
* start_time::
* start-time::
* content::
* schema::

Binary measurement data

* LONG_T type::
* DOUBLE_T type::
* DOUBLE_NAN type::
* STRING_T type::

@end detailmenu
@end menu

@node Introduction
@chapter Introduction

OML is the OMF Measurement Library.  It was created from a need to
filter, collect, store, retrieve, and analyze measurements produced in
the course of running experiments on large testbed networks, and
thence comes its name: OMF is the cOntrol and Management Framework
that provides mechanisms for defining and executing experiments on a
testbed network, and we wrote OML to collect measurements from OMF
experiments.

Why is a measurement library like OML necessary?  An experiment or a
simulation running on a single computer can generate a large
amount of measurement data, but this does not pose a significant
challenge to the experimenter because she can organize it using the
local filesystem.  An experiment that is run on the nodes of a
network, such as a simulation cluster or a testbed network, generates
even more data but distributes it over many nodes.  It then becomes a
challenge to collect, organize, and store the measurement data in a
central location.  Ad-hoc approaches to this problem tend to be
arduous and error-prone.  OML provides tools to solve the problem
systematically and conveniently.

@menu
* What is OML?::
* Organization of this manual::
@end menu

@node What is OML?
@section What is OML?

OML is a suite of software components that cooperate to collect and
store measurement data.  The two main components are the client
library, @code{liboml2}, and the server, @command{oml2-server}.

An experimenter writes a @dfn{client application} that performs some
measurements, and uses functions provided by @code{liboml2} to send
the measurements to either a file on the local filesystem, an OML
server running on another network host, or both.  It is also possible
to configure @code{liboml2} to do some filtering of the measurements
before they are sent to the file or server.

The @command{oml2-server} application is a network application that
listens for connections (either UDP or TCP) from client applications
running on other network hosts.  The client applications connect to
the server and transmit measurements to it via the network.  The
server then stores the measurements in a database.

Both @command{oml2-server} and @code{liboml2} are written in C, and
they were originally written for the Linux operating system on x86
machines, although they should be portable to other UNIX-like
operating systems.@footnote{Currently we don't have any plans to
actively port OML to other operating systems or architectures,
although we know of people who are using OML on ARM CPU's, and we know
OML compiles and runs on MacOS X.  We gladly accept patches, though!}

@node Organization of this manual
@section Organization of this manual

This manual begins with a tour of OML in @ref{Basic concepts of OML},
which describes the overall architecture, how the client library works,
and how the server works, conceptually.  Then in @ref{Client
applications}, we show how to write your experiment application to take
advantage of OML and how to configure the OML client library's sampling,
filtering, and measurement output at run time.  @ref{Server}, discusses
both the OML server, which stores measurements in a database for later
retrieval, and the OML proxy server, which can used to collect
measurements on network nodes that might sometimes be disconnected from
the network, such as mobile nodes.

The @code{liboml2} library uses a general filtering architecture to
filter measurements before sending them to a file or to an OML server.
This architecture is extensible: you can write your own
custom filters.  @ref{Custom Filters} expands on the concepts in
@ref{Client applications} to show you how to do this, and provides a
detailed reference for the filter writing API.

@node Basic concepts of OML
@chapter Basic concepts of OML
@node Client applications
@chapter Client application

@menu
* Client configuration::        How to configure an OML client application
@end menu

@node Client configuration
@section Client configuration

Client applications can be given options on the command line to
configure various aspects of the behaviour of the OML client library.
They can also be configured more extensively using a configuration
file in XML format.  For some users the command line configuration
will be sufficient, but the XML format provides more power for more
sophisticated measurement needs.

@menu
* Command line::                Configuring the OML client from the command line
* XML configuration::           Configuring the OML client using an XML file
* Configuration errors::        What happens if you make a mistake configuring OML
@end menu

@node Command line
@subsection Command line

The client application must initialize OML with a call to
@code{omlc_init()}, passing it the programme's command line argument
vector and count.  The @code{omlc_init()} function scans the command
line for options that it understands, configures OML according to
those options, and then removes the OML-specific options from the
argument vector.  This allows the client application to have its own
command line options without needing to worry about processing OML
options as well.

To see the available options, build your client application, linking
with @code{-loml2}, and then execute it with the @option{--oml-help}
option:
@example
$ my-oml-app --oml-help
@end example
@noindent

Here is how the @code{main()} function of a typical OML client
application might look:

@example
int main (int argc, char** argv)
@{
  int res;

  res = omlc_init ("my-oml-app", &argc, &argv, NULL);
  if (res < 0)
     return -1;  /* OML failed to initialise */
  else if (res == 1)
     return 0;  /* OML was disabled (e.g., with --oml-noop) */

  /* Do our own options processing, if required */
  ...
  /* Add MP's with omlc_add_mp() */
  ...

  res = omlc_start ();

  if (res)
     return (-2);  /* OML failed to start */

  /* Do the application, collect measurements with omlc_inject() */
  ...

  return 0; /* Program ran and finished successfully */
@}
@end example

The call to @code{omlc_init()} parses the OML command line options and
configures the library.  The @code{omlc_start()} function is responsible
for creating the filter configuration.  If there is no XML configuration
file specified (i.e. @option{--oml-config} is not given) then a default
filter configuration is used.  In this configuration, there is a single
collection URI, specified by either @option{--oml-collect}, and every MP
that has been previously registered by a call to @code{omlc_add_mp()} is
given a filter for every element of its input @math{n}-tuple.  The
filter type for each element of the @math{n}-tuple is chosen
automatically:

@itemize
@item
If the element is an @code{OML_LONG_VALUE} or an
@code{OML_DOUBLE_VALUE} then the averaging filter @code{avg} is used;

@item
If the elment is an @code{OML_STRING_VALUE}, then the first filter,
@code{first}, is used.
@end itemize

The following subsections describe all the OML command line options in
detail.

@menu
* omlid::
* omldomain::
* omlcollect::
* omlsamples::
* omlinterval::
* omlconfig::
* omllogfile::
* omlloglevel::
* omlnoop::
* omllistfilters::
* omlhelp::
@end menu


@node omlid
@subsubsection @option{--oml-id} @var{id}

@kindex --oml-id
Set the client application's node ID.  This is not required if output is
only going to a file, but it is mandatory if output is going to an OML
server, as the OML server uses the node ID (and the experimental domain)
to distinguish between measurements from different OML clients in the
network.

@node omldomain
@subsubsection @option{--oml-domain} @var{id}

@kindex --oml-domain
Set the client application's experimental domain.  This is not required
if output is only going to a file, but it is mandatory if output is
going to an OML server, as the OML server uses the domain (and the node
ID) to distinguish between measurements from different OML clients in
the network.

@node omlcollect
@subsubsection @option{--oml-collect} @var{uri}

@kindex --oml-collect
Send measurement output to the collection point indicated by the
@var{uri} parameter.  The @var{uri} can specify either UDP or TCP
protocol, together with a host and port number to connect to.  For
example:
@example
--oml-collect tcp:[2001:db8::1]:1234
@end example
@noindent
would connect to port 1234 on machine 192.0.2.1 using TCP protocol.

@node omlsamples
@subsubsection @option{--oml-samples} @var{n}

@kindex --oml-samples
Set the sampling policy to compute filter outputs every @var{n} input
samples for all defined measurement points.  Only one of
@option{--oml-samples} and @option{--oml-interval} should be specified
at the same time, otherwise an error will occur.

@node omlinterval
@subsubsection @option{--oml-interval} @var{period}

@kindex --oml-interval
Set the sampling policy to compute filter outputs every @var{period}
seconds for all defined measurement points.  Only one of
@option{--oml-interval} and @option{--oml-samples} should be specified
at the same time, otherwise an error will occur.

@node omlconfig
@subsubsection @option{--oml-config} @var{config-file}

@kindex --oml-config
Use an XML @var{config-file} to configure OML.  @xref{XML
configuration}.

@node omllogfile
@subsubsection @option{--oml-log-file} @var{log-file}

@kindex --oml-log-file
Log debug, informational, warning, and error messages to file
@var{log-file}.  If @var{log-file} is `@code{-}', then the output goes
to the client application's standard output stream.  Not all of the
four levels of logging are sent to the log file.  This is controlled
by @code{--oml-log-level}, @xref{omlloglevel}.

@node omlloglevel
@subsubsection @option{--oml-log-level} @var{level}

@kindex --oml-log-level
Control the amount of information logged to the OML log file.  The log
@var{level} is a number from 1 to 4:
@itemize
@item
@var{level}=1: Log only error messages to the log file.

@item
@var{level}=2: Log error messages and warnings to the log file.

@item
@var{level}=3: Log errors, warnings, and informational
messages to the log file.

@item
@var{level}=4: Log errors, warnings, informational messages and
debugging messages to the log file.
@end itemize

@node omlnoop
@subsubsection @option{--oml-noop}

@kindex --oml-noop
Don't write any measurements to file or any servers.  This is useful
if the OML client application needs to be run as part of a larger
experiment, but its output is not interesting for this particular
experiment.

@node omllistfilters
@subsubsection @option{--oml-list-filters}

@kindex --oml-filter-types
Print out the available filter types, for use in the XML configuration
file, then exit.

@node omlhelp
@subsubsection @option{--oml-help}

@kindex --oml-help
Print out a usage message listing all the available options, then
exit.

@page
@node XML configuration
@subsection XML configuration

@quotation Current implementation status
With reference to the text below, the parser is not fully implemented.
In particular, the filter parameters element @code{<fp/>} is parsed but
the key/value pair is not sent to the filter's @code{set()} function.
Also, the filter definition element @code{<f/>} has a defined
attribute @code{multi_pnames}, but it isn't processed or used in any
way.
@end quotation

While the command line provides a basic method for configuring OML,
with averaging filters on numeric measurements and either sample count
or interval based filtering, the full power of OML's filtering
capabilities can only be accessed via its XML configuration file
format.  The XML format allows the user of the OML client application
to choose multiple different filters for each measurement stream, and
to send the resulting filtered measurements to multiple different
destinations.  To use an XML file for configuring OML, pass it the
@option{--oml-config} option and specify a file as the argument.  For
example:
@example
$ my-oml-app --oml-config config.xml ...
@end example

@menu
* Root element::                The root element of the XML file.
* Data collectors::
* Definining measurement points::  How to define what measurements to collect.
* Defining filters::            How to create filters on each MP.
* Example XML configuration::
@end menu

@node Root element
@subsubsection Root element

The XML file must have a root element with tag @code{<omlc/>}.  The root
element can also specify the node identifier and the experiment
identifier, using the @code{id} and @code{domain} attributes,
respectively.  For example, suppose that the client is running on a
node called ``node-21'', and that this experiment is testing a new
WiFi networking algorithm called ``xtream-wifi''.  The XML
configuration file for this experiment might look like this:

@example
<omlc id="node-21" domain="xtream-wifi-1">
...
</omlc>
@end example

The @code{id} and @code{domain} attributes are not mandatory if
results are being written to a file, however the OML client library
can't send measurement output to an OML server without them.  In that
case, @code{omlc_start()} will return an error.

@node Data collectors
@subsubsection Data collectors
Under the root node there must be a list of one or more @code{<collect/>}
elements.  The collect element indicates a data destination (i.e. a
data ``collector'').  A data collector can represent either:

@itemize
@item
a file on the local filesystem;
@item
an OML server located on a network accessible from the machine on
which the client application is running; or
@item
an OML proxy server located on the same machine as the client
application.
@end itemize

The destination is specified using the @code{url} attribute of the
@code{<collect/>} element.  The following protocols are available:

@enumerate
@item
@code{file:} -- writes measurement data to a file on the local
filesystem.  For instance @code{<collect
url="file:/tmp/my-data.txt"/>} will write to the file
@file{/tmp/my-data.txt}.  Relative file names are interpreted relative
to the current working directory of the OML client application when it
launched.  A URL of @code{file:-} sends the output to the client
application's standard output stream.

@item
@code{tcp:} -- writes measurement data to a TCP connection that the
client library establishes. The destination host and port are encoded
in the URL.  For instance, @code{<collect
url="tcp://10.42.54.2:3003"/>} will write data for this collector to
TCP port 3003 of machine 10.42.54.2.

@item
@code{udp:} -- writes measurement data to a UDP connection that the
client library establishes.  The destination host and port are encoded
in the URL.  For instance, @code{<collect
url="udp://10.42.54.3:3004"/>}.
@end enumerate

The @code{url} attribute is a required attribute; it is an error to
omit it.  

The other (non-mandatory) attribute is @code{encoding} which specifies 
the protocol encoding to use when communicating with the destination. 
The regular OML server and the OML proxy server both
understand the same protocol, and are interchangeable from the point
of view of the OML client application.

There are currently two types available:

@enumerate
@item
@code{text} -- where tuples are separated by newlines and each element in 
a tuple is separated by a comma. 

@item
@code{binary} -- tuples and their values are encoded with a more efficient TLV-like protocol.
@end enumerate

If the encoding is not specifcially specified, the @code{binary} encoding is used for all
urls except the @code{file} type.



@node Definining measurement points
@subsubsection Defining measurement points
The @code{<collect/>} element groups one or more @code{<mp/>}
elements.  An @code{<mp/>} element is a representation of a
Measurement Point (MP).  Each @code{<mp/>} has a @code{name}
attribute, which is mandatory, and either a @code{samples} attribute
or an @code{interval} attribute.  The @code{name} attribute must match
the name of an MP that the client application registered using
@code{omlc_add_mp()}.

If @code{samples=n} is specified, where @code{n} is an integer, then
the MP will call its filters' @code{output()} functions after every
@code{n} samples, resulting in measurements being written to the MP's
collector.  If @code{interval=T}, where @code{T} is a floating point
number, then the MP will call its filters' @code{output()} functions
every @code{T} seconds, so the filtered measurements will be sent to
the collector's data store at that periodic interval.  Specifying both
@code{samples} and @code{interval} on the same @code{<mp/>} element is an
error.

Each @code{<mp/>} groups a number of filter specification elements, which
are given using the @code{<f/>} tag.  Thus, an example OML configuration
file with one collector, one MP, and two filters might look like the
following:

@example
<omlc id="node-21" domain="xtream-wifi-1">
      <collect url="file:xtream-wifi-1-output.txt">
               <mp name="packets" interval=1.0>
                   <f .../>
                   <f .../>
               </mp>
      </collect>
</omlc>
@end example


This assumes that the ``xtream-wifi'' client application has created
an MP named ``packets''.  This configuration could be used, for
instance, to count the number of packets received per second (since
the @code{interval} attribute is given with a 1 second period) using
the first filter, and also the delay between packets using the second
filter.

@node Defining filters
@subsubsection Defining filters
The @code{<f/>} element is used to select the type and parameters for the
filters attached to this MP.  All measurement samples injected into
the MP by the client application using calls to @code{omlc_inject()}
will be fed as input samples to all filters grouped under the MP.
Because the injected samples are @math{n}-tuples, and most (but not
all) filters are only interested in one element of the @math{n}-tuple,
the @code{<f/>} tag allows you to select which element of the
@math{n}-tuple gets sent to which filter.

A filter is typically specified as follows:
@example
<f fname="avg" sname="ip_len_avg" pname="ip_len"/>
@end example
@noindent
This filter might be used, for instance, to compute the average length
of IP packets received.  The @code{fname} attribute specifies the type
of filter to create.  In this case, an averaging filter (``avg'') is
being used.  The @code{sname} attribute gives a name to the filter,
which will appear in the schema sent to the datastore, so that outputs
from this filter can be distinguished from others.  Finally, the
@code{pname} attribute selects which element of the MP's input
@math{n}-tuple to use as the primary filter input.

The names of the available filter types can be determined by giving
the @option{--oml-filter-types} option to the client application.  The names
given there are appropriate to be used as the value of the
@code{fname} attribute.

@cartouche
@quotation Alternative proposal
Having three different attributes called ``@code{xname}'' is a bit confusing,
and makes it difficult for a new user to remember what the ``x'' part
means.  We could as an alternative rename these attributes:

@itemize
@item @code{fname} @result{} @code{type}
@item @code{sname} @result{} @code{name}
@item @code{pname} @result{} @code{parameter}
@end itemize

With this change the above example would look like this:
@example
<f name="ip_len_avg" type="avg" parameter="ip_len"/>
@end example
This makes it clear that the type of filter is an averaging filter,
the filter's identifier is @code{ip_len_avg}, and it is filtering the
MP's @code{ip_len} parameter.
@end quotation
@end cartouche

In this case, the filter is taking its primary input from the
@code{ip_len} parameter of the MP's @math{n}-tuple.  In general, the
parameter name specified via the @code{<f/>} tag's @code{pname}
attribute must match the name of a parameter in the MP's definition,
as supplied in a call to @code{oml_add_mp()} in the OML client
application.  If the name specified in the @code{pname} attribute
doesn't match any parameter of the MP under which the filter is
defined, an error occurs.  The @code{sname} attribute can be any string.

An @code{<f/>} element can optionally contain @code{<fp/>} children that
allow for setting filter properties.  We call them properties to avoid
confusion with the MP's parameters.  A property is a way of
customizing a filter's behaviour.  Properties are typed, named values.
Allowable types are @code{integer}, @code{double}, and @code{string}.
For instance, suppose a (hypothetical) filter type exists called
@code{fft} that computes the Fast Fourier Transform of its input data.
It might have an integer parameter @code{N} representing the size of
the FFT input/output, and string parameter @code{dir} to select
between an FFT and an IFFT.  This could be represented as follows:

@example
<f sname="vibration-fft" fname="fft" pname="displacement">
   <fp name="N" type="integer">32</fp>
   <fp name="dir" type="string">FFT</fp>
</f>
@end example

In this case the FFT size chosen is 32 and the forward FFT will be
computed, not the inverse FFT.

@node Example XML configuration
@subsubsection Example XML configuration

The previous sections described everything required to configure and
OML client application.  Here is a slightly longer example of an OML
XML configuration file.

@smallexample
<omlc domain="exp99" id="node11">
    <collect url="tcp:localhost:15500">
        <mp name="omlsigar" interval="2" >
            <f fname="avg" sname="cpu_user" pname="cpu_user" />
        </mp>
    </collect>

    <collect url="tcp:192.0.2.1:15502">
        <mp name="omlsigar" interval="2" >
            <f fname="avg" sname="rx_bytes" pname="rx_bytes"/>
            <f fname="histogram" sname="rx_hist" pname="rx_bytes">
                <fp name="key">rx_bytes</fp>
            </f>
        </mp>
    </collect>

    <collect url="file:-">
        <mp name="omlsigar" interval="2" >
            <f fname="avg" sname="rx_bytes" pname="rx_bytes"/>
            <f fname="avg" sname="tx_bytes" pname="tx_bytes"/>
        </mp>
    </collect>
</omlc>
@end smallexample

This example sends data to an OML sever at the localhost port 15500,
to another OML server at remote machine 192.0.2.1 port 15502, and to
the standard output on the local machine.  The localhost server
records the average CPU user time; the remote server records both the
average received bytes and a histogram of the average received bytes;
and the standard output prints both the average received and
transmitted bytes.

@node Configuration errors
@subsection Configuration errors
If an error is detected in the way that OML has been configured,
either on the command line or in an XML configuration file, then
@code{omlc_start()} will return with an error, and @code{omlc_init()}
might as well.  In that case, the client application will probably not
send measurements to the datastores; certainly not in the manner
intended.  It is probable that measurements will be lost, and this
behaviour is undefined.

Client applications must check the return values of both
@code{omlc_init()} @emph{and} @code{omlc_start()}.  If either returns
an error, the client application should print a diagnostic message and
quit with an error code.  The OML log file will contain log messages
indicating the nature of the problem.  You should inspect these log
messages and correct the problem before continuing.

@node Server
@chapter Server
@node Custom Filters
@chapter Custom Filters

OML comes with several built-in filters already available for use by
your applications.  The currently defined filters are:

@itemize
@item Average filter:  output the average, min and max of all the samples since the beginning of the experiment.
@item First filter:  output only the first sample in each sampling interval, and discard the rest.
@item Histogram filter:  record and output a histogram from the received measurements.
@end itemize

For many experiments these filters will be adequate.  OML provides a
mechanism for experimenters to write custom filters in situations
where the built-in filters do not provide the required functionality.
This chapter describes the API for defining custom filters in your
application, and gives an example of how to use it.

@menu
* Anatomy of a filter::         The basic components of an OML filter.
* Filter API::                  The interface for filter writers.
@end menu

@node Anatomy of a filter
@section Anatomy of a filter

An OML filter is a processing element that accepts a stream of values
from an MP and produces output that is some function of the input
stream.  Typically a filter should produce output samples at a reduced
rate compared to the input sample rate, although OML does not enforce
this rule.  One significant reason for filtering is to reduce the
amount of data produced by an experiment to a more manageable level.
Another is to provide multiple alternative ways for looking at the
experiment's result set.

Each filter is attached to an MP when it is created.  The filter input
stream therefore consists of @math{n}-tuples, where @math{n} is the
width of the MP's input (as defined by a call to
@code{omlc_add_mp()}).  The output stream of the filter consists of
@math{m}-tuples, where @math{m} is defined by the filter writer.

Note that the output width, @math{m}, is fixed by the filter writer
and cannot change at runtime, whereas the input width, @math{n}, is
defined by the MP to which the filter is attached, and is by nature a
dynamic runtime quantity.

Internally to the OML client library, a description of every type of
filter is stored in a factory.  This description consists of the
following:

@itemize
@item a create function, called @code{create()} in the following discussion;
@item a parameter setting function, called @code{set()};
@item a new sample input function, called @code{input()};
@item a filter output function, called @code{output()};
@item a meta function, called @code{meta()}; and
@item an output description.
@end itemize

These functions and the output description are all provided by the
filter writer via a call to @code{omlf_register_filter()}.  The
@code{omlf_register_filter()} function and the required API for all of
the user-provided functions are described fully in @ref{Filter API}.

New filters instances are created during the call to
@code{omlc_start()}, according to either OML command line options or
according to the XML configuration file, if specified. There can be
multiple instances of each type of filter, including user-defined
filters. Each instance is created by a call to the @code{create()}
function for the filter type. The @code{create()} function for a filter
should allocate memory for any internal state that it needs to maintain,
and should initialize the state appropriately.

When the application begins running and generating measurement data,
every time an MP receives new data from the application (in a call to
@code{omlc_inject()}) it passes the sample data to all of its attached
filters by calling their @code{input()} functions.  The input function
should update the internal state of the filter to reflect the new
sample.

Each MP is defined with a sampling policy: it produces outputs either
when a set time interval has elapsed, or when a set number of samples
has been injected into the MP.  When an MP's sampling policy dictates
that it should output a measurement, the MP will call the filter's
@code{output()} function.  The @code{output()} function computes an
output @math{m}-tuple based on all the previous samples, as reflected
in its current internal state.  It must then send the output
@math{m}-tuple to a writer object (provided by the OML client
library), which either writes the output sample to file or sends it to
the configured OML server.

Once the output has been written to the data store, the
@code{output()} function can reset any of its internal state as needed
to be ready for the next set of samples to be injected into the MP.
For instance, an averaging filter might reset its accumlator and count
variables to zero at this point.

The final aspect of a filter is the @code{meta()} function.  This
function is used by OML to construct a schema to describe the filter's
output.  The schema is used by the OML server to construct a database
table to store the filter's output, and is always written out to file
if the filter is configured to output its data to a local file.  The
output description can be used to generate the schema automatically,
in which case the @code{meta()} function is not required; but if you
want to change the default schema produced from the output
description, you can provide your own meta function.

TODO: The above might be more enlightening with references to the XML
config format (@pxref{XML configuration}).

@node Filter API
@section Filter API

This section introduces the API for writing filters.  It consists of
two parts:

@enumerate
@item
Utility functions for registering a new filter type and for accessing
elements of a filter instance; and
@item
Function prototypes and functional descriptions that the user-provided
filter functions must conform to.
@end enumerate

Both the utility functions and the user-provided function prototypes
definitions are contained in the file @file{oml_filter.h}.
@pindex oml_filter.h

Following this section is a brief tutorial showing how to use this API
in practice.  @xref{Filter Tutorial}.

@menu
* Utility functions::           Functions for operating on filters.
* Filter function prototypes::  The API that new filters must conform to.
* Filter Tutorial::             A tutorial showing how to define your own filters.
@end menu

@node Utility functions
@subsection Utility functions

@deftp Struct OmlFilter
Struct representing an instance of a filter.  The OML client library
creates filter instances during the call to @code{omlc_start()}, based
on the definitions in the filter factory.  The @code{OmlFilter} struct
stores the filter instance's private instance data, as registered by
the @code{omlf_set_instance_data()} function.  All of the filter
functions provided by the filter writer take an @code{OmlFilter*} as
their first parameter (see @ref{Filter function prototypes}).  The
filter writer can use this pointer to set and access the instance
data, query properties of the filter, and perform other necessary
operations.  The rest of the functions in this section all operate on
@code{OmlFilter} objects.
@end deftp

@deftp Struct OmlFilterDef
Struct representing the definition of a filter's output, defined as
follows:

@example
typedef struct OmlFilterDef
@{
        const char* name;
        OmlValueT   type;
@} OmlFilterDef;
@end example

When a new filter type is registered with
@code{omlf_register_filter()}, the filter output @math{m}-tuple must
be defined as an array of (name, type) pairs, represented using
@code{OmlFilterDef}.  The filter designer should create an array of
@math{m+1} @code{OmlFilterDef} objects specifying the output
@math{m}-tuple of the filter, terminated by a sentinel initialized as
@code{@{ NULL, 0 @}}, and pass it to @code{omlf_register_filter()}.
@end deftp


@deftypefun int omlf_register_filter ( @* @
           @code{const char*}       @var{filter_name}, @* @
           @code{oml_filter_create} @var{create},      @* @
           @code{oml_filter_set}    @var{set},         @* @
           @code{oml_filter_input}  @var{input},       @* @
           @code{oml_filter_output} @var{output},      @* @
           @code{oml_filter_meta}   @var{meta},        @* @
           @code{OmlFilterDef*}     @var{filter_def})

Register a new filter type with the OML client library's internal
filter factory.

The filter type is identified by the given @var{name}.  The @var{name}
can be used in the XML configuration file to create instances of this
type of filter.  Instances of this filter type will be created by a
call to the given @var{create} function.  The OML client library will
call the given @var{set}, @var{input}, @var{output} and @var{meta}
functions for filter instances of type @var{filter_name}.

This function returns 0 on success and @minus{1} on error.

The @var{create}, @var{input}, and @var{output} functions are required
and cannot be @code{NULL}.  If they are @code{NULL} then the filter
type will not be registered with the factory and the function will
return @minus{1} (error).

If the @var{set} parameter is @code{NULL} then no error is generated
and a default @code{set()} function, a no-op, is installed for this
filter type.

If the @var{meta} parameter is @code{NULL} then a default
@code{meta()} function is installed for this filter type.  The default
@code{meta()} function inspects the @var{filter_def} and automatically
generates the schema information from it.

The @var{filter_def} must point to an array of @code{OmlFilterDef}
structs, terminated by a sentinel.  For example, it might look like
the following:

@example
OmlFilterDef my_filter_def [] =
@{
        @{ "avg", OML_DOUBLE_VALUE @},
        @{ "min", OML_LONG_VALUE @},
        @{ "max", OML_LONG_VALUE @},
        @{ NULL, 0 @}
@};
@end example

The @var{filter_def} is also mandatory.  If it is @code{NULL}, an
error will occur and the function returns @minus{1}.  If the type of
an entry in the @var{filter_def} array is the pseudo-type
@code{OML_INPUT_VALUE}, then the output type will be set to the type
of the filter's primary input.

The types @code{oml_filter_create}, @code{oml_filter_set}, etc., are
function pointer types.  They are defined separately in @ref{Filter
function prototypes}.
@end deftypefun

@deftypefun int omlf_set_instance_data (@code{OmlFilter*} f, @code{void*} instance_data)
Set the private instance data for filter @var{f}.  This function
returns 0 on success and @minus{1} on failure.  The function will fail
if the filter already has private instance data, or if
@var{instance_data} is @code{NULL}.
@end deftypefun

@deftypefun void* omlf_instance_data (@code{OmlFilter*} f)
Return the private instance data for filter @var{f}, or @code{NULL} if
no private data has been registered for this filter yet.
@quotation Implementation note
This function could be implemented as either an inline function or a
macro for speed.
@end quotation
@end deftypefun

@deftypefun OmlValue* omlf_create_result_vector (@code{OmlFilter*} f, @code{OmlValueT*} type, @code{unsigned int} n)
Creates a new result vector for filter @var{f}, and returns a pointer
to it.

If @var{type} is @code{NULL}, the result vector is a vector of
@code{OmlValue} objects whose types are initialized to match the types
specified in the filter's output definition, as supplied to
@code{omlf_register_filter()}.  Otherwise, @var{type} should point to an
array of length @var{n} of @code{OmlValueT} objects, specifying the type of
each field in the output @math{m}-tuple of the filter.

The values stored in the vector are initialized to 0 for numeric types
and @code{NULL} for pointer types (strings).

Returns @code{NULL} on failure.
@end deftypefun

@deftypefun @code{OmlValueT} omlf_input_type (@code{OmlFilter*} f, @code{int} index)
Return the type of the filter input with the given @var{index} for
filter @var{f}.  If @var{index} is not in the range @code{0..m-1},
where @code{m} is the input width (as returned by
@code{omlf_input_width()}), then this call will fail with the return
value @code{OML_UNKNOWN_VALUE}.
@quotation Implementation note
This function could be implemented as either an inline function or a
macro for speed.
@end quotation
@end deftypefun

@deftypefun int omlf_input_width (@code{OmlFilter*} f)
Returns the input width of filter @var{f}.  The input width is the
length of the filter's input tuple.  The input width is calculated from the
definition of the MP to which this filter is associated.
@quotation Implementation note
This function could be implemented as either an inline function or a
macro for speed.
@end quotation
@end deftypefun

@deftypefun int omlf_output_width (@code{OmlFilter*} f)
Returns the output width of filter @var{f}.  The output width is the
length of the filter's output tuple.  The output width is calculated from the
filter definition supplied to @code{omlf_register_filter()}.
@quotation Implementation note
This function could be implemented as either an inline function or a
macro for speed.
@end quotation
@end deftypefun

@deftypefun int omlf_write_output (@code{OmlFilter*} f, @code{OmlValue*} result)
Write the @var{result} vector for filter @var{f} to the data store.
Returns 0 on success and @minus{1} on failure.

This function is intended to be called from the filter's
@code{output()} function.  Most filters will call this function once
per invocation of the @code{output()} function.  However, some filters
may need to output multiple lines of results, all adhering to the
filter's output schema, for every call to @code{output()}.  In this
case, the filter's @code{create()} function should call
@code{omlf_set_multiline()}.  This will cause the
@code{omlf_write_output()} function to emit an epoch on each line of
output, and augment the schema to match it.

The epoch is an incrementing counter that starts from 0 and increments
after each call to the filter's @code{output()} function.  Thus, all
filter outputs that logically belong to the same filtered measurement
sample will have the same epoch.

Note:  the filter definition passed to @code{omlf_register_filter()}
does not need to be modified to include the epoch, it will be included
in the schema automatically.  Even if you supply your own
@code{meta()} function, you can write it as normal and the OML client
library will take care of modifying the schema for multiline operation
with an epoch included in the schema.

@quotation Implementation note
This function will write output to the associated writer object, which
will be made available in the filter instance's @code{OmlFilter}
struct.
@end quotation
@end deftypefun

@deftypefun int omlf_set_multiline (@code{OmlFilter*} f)
Set the filter @var{f} to multiline mode.  In multiline mode, the
filter's @code{output()} function can call the
@code{omlf_write_output()} function more than once, and the
measurement results will be augmented with an incrementing epoch that
groups all related measurement outputs.

This function must only be called within the filter's @code{create()} function.

Returns 0 on success, @minus{1} on failure.
@end deftypefun

@node Filter function prototypes
@subsection Filter function prototypes

The core of a user-defined filter is the set of functions it provides
to the OML client library.  This set of functions must conform to the
API expected by OML, which is documented in this section.  You should
write your filter's functions to match the descriptions below.

@deftypefun @code{typedef int} (*oml_filter_create) ( @* @code{OmlFilter*} f, @* @code{OmlValueT} type)
Prototype for every filter's @code{create()} function.  The create
function is called when a new instance of this type of filter is
created.  The OML client library first sets up the @code{OmlFilter}
struct for this filter, then calls the @code{create()} function, so
the filter is fully constructed (apart from instance data) and in a
suitable state for all the functions in @ref{Utility functions} to be
callable on @var{f}.

The @var{type} parameter is the type of the filter's primary input
value.  The @code{create()} function can cache this parameter and do
polymorphic filtering based on the input type, or alternatively it can
do type checking to ensure that the filter is used only with valid
input types.

The create function is responsible for initializing the internal state
for the new instance of the filter type it belongs to.  Most filters
would allocate memory for a private instance data structure,
initialize the structure, and call @code{omlf_set_instance_data()} to
register its instance data with the @code{OmlFilter} instance.  It
should probably also call @code{omlf_create_result_vector()} to
allocate an array to store its output.

For instance, the @code{create()} function for the built-in averaging
filter looks something like this:

@smallexample
typedef struct @{
  /* Keep the sum and sample count to calculate average */
  double  sample_sum;
  int     sample_count;

  double  sample_min;
  double  sample_max;

  OmlValue* result;
@} InstanceData;

int average_create (OmlFilter* f, OmlValueT type)
@{
   /* Validate the input type */
   if (! (type == OML_LONG_VALUE || type == OML_DOUBLE_VALUE))
     return -1;

   /* Allocate private instance data structure */
   InstanceData* self = (InstanceData*)malloc(sizeof(InstanceData));

   if (!self)
     return -1;

   /* Initialize private instance data for computing avg, min, max */
   memset(self, 0, sizeof(InstanceData));
   self->sample_sum = 0;
   self->sample_count = 0;
   self->sample_min = HUGE;
   self->sample_max = -1 * HUGE;

   /* Create the result vector, and save it */
   self->result = omlf_create_result_vector(f, NULL, 0);

   /* Store the private instance data for this filter instance */
   omlf_set_instance_data(f, self);
   return 0;
@}
@end smallexample

If a filter is intended to operating in multiline mode, then its
@code{create()} function should call @code{omlf_set_multiline()}.

The @code{create()} function should return 0 on success and @minus{1}
on failure.  If it signals a failure, then the filter factory will log
an error to the OML log and the filter instance will not be created.
The @code{create()} function should @code{free()} and memory it
allocated before it exits in this case, including any instance data
set via a call to @code{omlf_set_instance_data()}.
@end deftypefun


@deftypefun @code{typedef int} (*oml_filter_set)      ( @* @code{OmlFilter*} f, @* @code{const char*} name, @* @code{OmlValue*} value)
Prototype for every filter's @code{set()} function.  The @code{set()}
function is called by the OML client library to set parameters for the
filter.  The parameter is specified as having the given @var{name} and
@var{value} in the XML configuration file (see section XXX).

It is up to the individual filter to store parameter values, most
typically in its instance data.  It is free to ignore parameters if
they are not meaningful for the particular filter type, but its
@code{set()} function should return @minus{1} in this case to indicate
failure.  On success, the @code{set()} function should return 0.
@end deftypefun


@deftypefun @code{typedef int} (*oml_filter_input)    ( @* @code{OmlFilter*} f, @* @code{OmlValue*} primary, @* @code{OmlValueU*} values)
Prototype for every filter's @code{input} function.  The input
function is called once for every time that the application calls
@code{omlc_inject()} on the MP to which the filter instance is
associated.  This function should update its internal state to reflect
the new sample data.

The @code{input()} function can use @code{omlf_instance_data(f)} to
get access to the private instance data of filter @var{f}.  Parameter
@var{f} is guaranteed to represent a filter of the correct type.

The @var{primary} parameter is a pointer to the primary input value
for this filter, for this input sample.  See this discussion of
primary input values in section XXX.  Since it is an @code{OmlValue}
object, the primary input value is typed and can be validated for type
checking, or handled differently for different types.

The @var{values} parameter points to the array of input values from
the MP, i.e. it is the pointer to the MP's input @math{n}-tuple for
the current input sample, where @math{n} is the value returned by
@code{omlf_input_width()}.

The @var{values} array is an array of @code{OmlValueU}'s, which are
untyped.  This is for efficiency.  The filter can check the types of
the elements of the @var{values} array by making calls to
@code{omlf_input_type()}.

Note that the value of @var{primary} will be present in the
@var{values} array.  The reason for supplying @var{primary} is for
convenience.  Many filters only require a single input value to filter
(for instance, the built-in averaging filter).  For such filters,
@var{primary} will be sufficient and more convenient than indexing the
@var{values} array; the @var{values} array can be ignored in that
case.  However, some filters may need to do computations on multiple
elements of the MP's input @math{n}-tuple, and for these filters the
@var{values} array is provided.

The @code{input()} function should return 0 on success, and @minus{1} to
indicate a failure.
@end deftypefun

@deftypefun @code{typedef int} (*oml_filter_output)   (@code{OmlFilter*} f)
Prototype for every filter's @code{output()} function.  The
@code{output()} function should perform any finalization of the
accumulated filter state, store the output values in a result vector,
and pass the result vector to the @code{omlf_write_output()} function.

If the filter is set to use multiline operation, the @code{output()}
function can make multiple calls to @code{omlf_write_output()}.

The @code{output()} function should return 0 on success and @minus{1}
on failure.
@end deftypefun

@deftypefun @code{typedef int} (*oml_filter_meta)     ( @* @code{OmlFilter*} f, @* @code{int} index, @* @code{char**} name_ptr, @* @code{OmlValueT*} type)
Prototype for every filter's @code{meta()} function.  The
@code{meta()} function's purpose is to provide the name and type of
every element of the filter's output @math{m}-tuple, so that the OML
client library can construct a schema for the filter.  The @var{index}
parameter indicates which element of the output @math{m}-tuple is
being queried.  The @code{meta()} function should set @var{*name_ptr}
to point to a string representing the name of the output element, and
@var{*type} to the type of the output element (@var{name_ptr} and
@var{type} are output-parameters).

For instance, here is the built-in averaging filter's @code{meta()}
function:

@smallexample
int meta(OmlFilter* f, int index, char** name_ptr, OmlValueT* type)
@{
  if (!f || !name_ptr || !type) return -1;
  if (index > 2) return -1;

  switch (index) @{
  case 0:
    *name_ptr = "avg";
    break;
  case 1:
    *name_ptr = "min";
    break;
  case 2:
    *name_ptr = "max";
    break;
  @}
  *type = OML_DOUBLE_VALUE;
  return 0;
@}
@end smallexample

The averaging filter's output @math{m}-tuple is an array of
@code{OML_DOUBLE_VALUE}s.  The first element of the output
@math{m}-tuple is called ``avg'', the second ``min'', the third
``max''.

The @code{meta()} function should return 0 on success and -1 on
failure.  In particular, if the @var{index} parameter is out of range
or one of the @var{name_ptr} or @var{type} variables are @code{NULL},
the function should fail.
@end deftypefun

@node Filter Tutorial
@subsection Filter tutorial

@node Non-instrumented Applications
@chapter Non-instrumented Applications

@node Language Bindings
@chapter Bindings for other languages

@menu
* Ruby::                        Bindings for Ruby
* Python::                      Bindings for Python
@end menu

@node Ruby
@section Ruby

@node Python
@section Python

@node Measurement Database
@chapter Measurement Database


@node Server protocol
@chapter Server protocol

The OML server accepts connections from clients and responds to a custom
protocol.  The protocol is one-way: the client connects to the server
and transmits its measurement data, but the server does not respond to
the client with any control or acknowledgement messages.  Any number of
clients can simultaneously connect to the server (subject to operating
system limits).

There are two variants of the protocol:  a binary variant and a text
variant.  The client declares the variant of the protocol it wishes to
use when it initiates the connection.  It is possible for multiple
clients to be communicating with the server simultaneously using either
variant.  A client cannot change the protocol variant it is using
during the life of the connection.

The protocol is divided into two parts:  the client sends a set of
configuration headers in the first part, and then sends its measurement
data in the second part.  The two parts are separated by two consecutive
new line characters (`@code{\n}', 0x0A).  The following grammar describes the
format for the headers:

@multitable @columnfractions .22 .05 .80

@item @var{oml-stream} @tab : @tab  @var{oml-headers} `@code{\n}' `@code{\n}' @var{measurement-data}

@item @var{oml-headers} @tab : @tab @var{oml-headers} `@code{\n}' @var{oml-header} | @var{oml-header}

@item @var{oml-header} @tab : @tab  @var{header-key} `@code{:}' @var{header-value}

@item @var{header-key} @tab : @tab    @code{protocol} | @*
                       @code{app-name} | @*
                       @code{sender-id} | @*
                       @code{experiment-id} | @*
                       @code{domain} | @*
                       @code{start_time} | @*
                       @code{start-time} | @*
                       @code{content} | @*
                       @code{schema}

@item @var{measurement-data} @tab : @tab @var{measurement-data-binary}
| @var{measurement-data-text}

@end multitable

It is acceptable for there to be whitespace separating the header key
names and the header values from the delimiter colon (`@code{:}').
The acceptable values for the headers are shown in the next section,
followed by the formats for the text and binary measurement data.

@menu
* Protocol headers::
* Binary measurement data::
* Text measurement data::
@end menu

@node Protocol headers
@section Protocol headers

The majority of the protocol headers are expected to appear only once
in the headers part for each client's data stream.  The exception is
the @code{schema} header, which can appear multiple times.  If any of
the other headers appear more than once, the server will accept the
header without complaint, but the results will be undefined and may
cause improper behaviour of the server.  Omission of any header except
@code{app-name} will also result in undefined behaviour.  The
@code{sender-id} header must follow the @code{domain} header,
otherwise the server will report an error and drop the connection to
the client.

@menu
* Protocol::
* app-name::
* sender-id::
* domain::
* experiment-id::
* start_time::
* start-time::
* content::
* schema::
@end menu

@node Protocol
@subsection @code{protocol}

The @code{protocol} header identifies the version of the protocol that
the client is using.  If the server implements a different version of
the protocol, the server will drop the client connection and no
measurements from that client will be stored in the experiment database.

Currently the supported protocol version is 1.

@node app-name
@subsection @code{app-name}

The @code{app-name} header is not used and is ignored by the server.

@node sender-id
@subsection @code{sender-id}

The @code{sender-id} header is used to identify the client to the
server.  The OML client library sends the argument of the
@code{--oml-id} command line option as the value of this header.

@node domain
@subsection @code{domain}

The @code{domain} header names the database in which the client's
measurements should be stored; all measurement data from the same
experiment is stored in a single database.  The OML client library sends
the argument given to the @code{--oml-domain} command line option as the
value of this header.

@node experiment-id
@subsection @code{experiment-id}

The @code{experiment-id} header is a synonym for the @code{domain}
header, supported for backwards compatibility reasons.

@node start_time
@subsection @code{start_time}

The @code{start_time} header is a synonym for the @code{start-time}
header, supported for backwards compatibility reasons.

@node start-time
@subsection @code{start-time}

The @code{start-time} header specifies the client time reference. It
should be an integer that gives the timestamp of client when the client
application started. This is used to synchronize timestamps of all
measurements from all clients in a given experiment. It should be
generated as the @code{tv_sec} member of the @code{struct timeval}
object returned by a call to @code{gettimeofday(2)} on the client.

@node content
@subsection @code{content}

The value of the @code{content} header may be either @code{text} or
@code{binary}.  Any other value is an error;  in that case the server
will assume text data, but this should behaviour should be changed to
drop the client in a future version.

The @code{content} header determines how the server will interpret the
subsequent measurement data stream.

@node schema
@subsection @code{schema}

The @code{schema} header specifies the schema for one measurement
stream.  There can be multiple measurement streams for each client, and
thus there can be multiple @code{schema} header lines transmitted by a
single client.

The @code{schema} header value consists of a measurement stream (MS)
index, an MS name, and a string of variable:type pairs, colon-separated:

@multitable @columnfractions .15 .05 .80

@item @var{schema-value}
@tab :
@tab @var{ms-index} @var{ms-name} @var{field-specs}

@item @var{field-specs}
@tab :
@tab @var{field-specs} @var{field-spec} | @var{field-spec}

@item @var{field-spec}
@tab :
@tab @var{field-name} `@code{:}' @var{field-type}

@item @var{field-type}
@tab :
@tab @code{long} | @code{double} | @code{string}

@end multitable


Valid field names should be alpha-numeric identifiers containing no
spaces; they may contain a hyphen `-' or underscore `_'.

The MS name is used to identify into which database table to insert
measurements for this client. The MS index is used to associate
subsequent measurement messages with this MS, so that the server knows
which table it should insert each measurement into.  See also...

@node Binary measurement data
@section Binary measurement data

If the @code{content} header is set to @code{binary} by the client, then
the server will begin interpreting the @code{measurement-data} as
@code{measurement-data-binary} for that client.  The binary protocol
consists of a sequence of binary messages, each of each corresponds to
the output of one measurement point/stream on the client,
post-filtering.  Thus, each of the binary messages represents an
@math{m}-tuple of measurement values, each of which could have a
different type.  Each binary measurement message follows the same
format, which begins with its own header.

The message format is shown below:


@example

Octet#   Datum
-----------------------------
0      |  SYNC-BYTE
1      |  SYNC-BYTE
2      |  OMB_DATA_P
3      |  msg-len-H
4      |  msg-len-L
5      |  num-measurements
6      |  ms-index
-----------------------------
7      |
8      |   Typed Binary Values
9      |
...    |      ...
@end example

The @code{SYNC-BYTE} identifies the start of a binary measurement
message and is equal to 0xAA.  The @code{OMB_DATA_P} identifies the type of
packet, and is equal to 1.

The @code{msg-len-L} and @code{msg-len-H} together form a 16-bit
unsigned integer, @code{msg-len} that the client sets equal to the
number of octets in the entire message, less 5; i.e. it is the number
of octets following the @code{msg-len-L} octet.  This integer is
transmitted in network byte order, and so the @code{ntohs()} function
should be used to portably read it on a server implementation.

The @code{num-measurements} octet specifies the number of measurement
fields in the message, and the @code{ms-index} identifies the
measurement stream to which this measurement message belongs.  It is
the same as the @code{ms-index} specified in the @code{schema} header
for this measurement stream.

All of the octets following the @code{ms-index} octet belong to typed binary
value objects.  A typed binary value object is a binary representation
of a numeric or string value sent by the client.  The first octet of a
typed binary value identifies the type of the object.  The
interpretation of the following octets of the typed binary value
depend on the type.  The lengths of typed binary value objects vary
depending on the type as well.

If the first 7 octets up to and including the @code{ms-index} octet
form the binary message header, then the binary message can be
described by the following grammar:

@multitable @columnfractions .31 .05 .64

@item @var{oml-binary-message}
@tab :
@tab @var{header} @var{typed-binary-values}

@item @var{typed-binary-values}
@tab :
@tab @var{seq-no} @var{timestamp} @var{typed-binary-measurements}

@item @var{typed-binary-measurements}
@tab :
@tab @var{typed-binary-measurements} @var{typed-binary-value} | @*
@var{typed-binary-value}

@item @var{seq-no}
@tab :
@tab @var{typed-binary-value}

@item @var{timestamp}
@tab :
@tab @var{typed-binary-value}

@end multitable



The @code{seq-no} is an incrementing sequence number represented as a
typed binary value object.  The timestamp is a floating point
timestamp that represents the number of seconds between the client's
@code{start-time} header value and the time when the measurement
values in this packet were captured and sent to the server.  The
@code{typed-binary-measurements} are the actual application
measurement data, and they should be exactly equal in number to
@code{num-measurements}.

There are four supported @code{typed-binary-value} types:
@enumerate
@item
@code{LONG_T}:  32-bit signed long integer values;
@item
@code{DOUBLE_T}:  Double precision floating point values;
@item
@code{DOUBLE_NAN}:  A type representing the floating point
``Not-a-Number'' (NaN) value;
@item
@code{STRING_T}:  A type representing character string values.
@end enumerate

@menu
* LONG_T type::
* DOUBLE_T type::
* DOUBLE_NAN type::
* STRING_T type::
@end menu

@node LONG_T type
@subsection @code{LONG_T}
The format of the @code{LONG_T} type is:
@example
Octet#   Datum
-----------------------------
0      |  LONG_T
1      |  long-byte-3
2      |  long-byte-2
3      |  long-byte-1
4      |  long-byte-0
-----------------------------
@end example

The value of the first octet is @code{LONG_T=0x1}, which identifies
the type.  The following four octets are the four 8-bit bytes of the
32-bit long integer, in network byte order.  A portable server
implementation should read this integer back using @code{ntohl()}.
The octet labelled @code{long-byte-3} is the most significant byte,
and the byte labelled @code{long-byte-0} is the least significant byte.

@node DOUBLE_T type
@subsection @code{DOUBLE_T}
The format of the @code{DOUBLE_T} type is:
@example
Octet#   Datum
-----------------------------
0      |  DOUBLE_T
1      |  mant-byte-3
2      |  mant-byte-2
3      |  mant-byte-1
4      |  mant-byte-0
5      |  exp
-----------------------------
@end example
The value of the first octet is @code{DOUBLE_T=0x2}, which identifies
the type.  The following four octets are the four 8-bit bytes of a
32-bit signed long integer representation of the mantissa of the
floating point value, in network byte order.  A portable server
implementation should read this integer back using @code{ntohl()}.
Following the mantissa is the exponent, represented as a signed byte.

The mantissa word is transmitted in a scaled representation; the
scaling factor is @math{2^{30}}.  The original floating point value
should be reconstructed using the formula
@iftex
@tex
$$
v = {2^x M \over 2^{30}}
$$
@end tex
@end iftex
@ifhtml
<p align=''center''>v = (2^x * M) / (2^30)</p>
@end ifhtml
where @math{M} is the mantissa and @math{x} is the exponent.

@node DOUBLE_NAN type
@subsection @code{DOUBLE_NAN}
The @code{DOUBLE_NAN} is a pseudo-type that represents the floating
point value Not-a-Number (NaN).  Its format is identical to the
@code{DOUBLE_T} type, but the first octet is equal to
@code{DOUBLE_NAN=0x3}, and the remaining five octets do not contain
any valid data.

@node STRING_T type
@subsection @code{STRING_T}
The format of the @code{STRING_T} type is:
@example
Octet#   Datum
-----------------------------
0      |  STRING_T
1      |  N
2      |  str-byte-0
3      |  str-byte-1
...
N+1    |  str-byte-(N-1)
-----------------------------
@end example
The value of the first octet is @code{STRING_T=0x4}, which identifies
the type.  The second octet is @code{N}, the length of the string.
The length of a string is limited to 254 8-bit characters, not
including a null-terminator.  The third and subsequent octets are the
string data, not including any null-terminator.

@node Text measurement data
@section Text measurement data


@node Index
@unnumbered Index

@printindex ky
@printindex cp

@bye


@bye
