/*
 * This file was automatically generated by oml2-scaffold V2.12.0pre.79-58cf-dirty
 * for /home/ubuntu/soml/example/liboml2/generator version 1.0.0.
 * Please edit to suit your needs; the run() function should contain application code.
 */

#include <unistd.h> /* Needed for sleep(3) in run() */
#include <signal.h>
#include <string.h>
#include <popt.h>
#include <oml2/omlc.h>

#define USE_OPTS /* Include command line parsing code*/
#include "/home/ubuntu/soml/example/liboml2/generator_popt.h"

#define OML_FROM_MAIN /* Define storage for some global variables; #define this in only one file */
#include "/home/ubuntu/soml/example/liboml2/generator_oml.h"

#include "config.h"

int loop = 1;

static void
sighandler (int signum) {
  switch (signum) {
    case SIGINT:
      /* Terminate on SIGINT */
      loop = 0;
      break;

  }
}

/* Do application-specific work here.
 */
void
run(opts_t *opts, oml_mps_t *oml_mps)
{
  long val = 1;
  struct sigaction sa;

  bzero(&sa, sizeof(struct sigaction));
  sa.sa_handler = sighandler;
  sigaction(SIGINT, &sa, NULL);

  static const bool vector_bool_field[] = {
    true, false, true, false
  };
  static const size_t vector_bool_field_len = sizeof(vector_bool_field)/sizeof(vector_bool_field[0]);

  static const double vector_double_field[] = {
    0.0, M_E, M_PI, HUGE, 1.0/0.0
  };
  static const size_t vector_double_field_len = sizeof(vector_double_field)/sizeof(vector_double_field[0]);

  static const int32_t vector_int32_field[] = {
    0, -1, 1, INT32_MIN, INT32_MAX
  };
  static const size_t vector_int32_field_len = sizeof(vector_int32_field)/sizeof(vector_int32_field[0]);

  static const uint32_t vector_uint32_field[] = {
    0, 1, 2, UINT32_MAX -2, UINT32_MAX -1, UINT32_MAX
  };
  static const size_t vector_uint32_field_len = sizeof(vector_uint32_field)/sizeof(vector_uint32_field[0]);

  static const int64_t vector_int64_field[] = {
    0, -1, 1, INT32_MIN - UINT64_C(1), INT64_MIN, INT32_MAX + UINT64_C(1), INT64_MAX
  };
  static const size_t vector_int64_field_len = sizeof(vector_int64_field)/sizeof(vector_int64_field[0]);

  static const uint64_t vector_uint64_field[] = {
    0, 1, 2, UINT32_MAX + UINT64_C(1), UINT64_MAX -1, UINT64_MAX
  };
  static const size_t vector_uint64_field_len = sizeof(vector_uint64_field)/sizeof(vector_uint64_field[0]);


  do {
    /* The oml_inject_MPNAME() helpers are defined in /home/ubuntu/soml/example/liboml2/generator_oml.h*/
    if(oml_inject_sensor(oml_mps->sensor, ((int32_t)-val), 1.0/val, "foo") != 0) {
      logwarn("Failed to inject data into MP 'sensor'\n");
    }
    if(oml_inject_example(oml_mps->example, OMLC_GUID_NULL, vector_bool_field, vector_bool_field_len, ((uint32_t)val), vector_double_field, vector_double_field_len, ((int64_t)-val), vector_int32_field, vector_int32_field_len, ((uint64_t)val), (val%5), vector_uint32_field, vector_uint32_field_len, 1.0/val, vector_int64_field, vector_int64_field_len, NULL, 0, vector_uint64_field, vector_uint64_field_len, ((int32_t)-val), "foo") != 0) {
      logwarn("Failed to inject data into MP 'example'\n");
    }

    val += 2;
    sleep(1);
  } while (loop);
}

int
main(int argc, const char *argv[])
{
  int c, i, ret;

  /* Reconstruct command line */
  size_t cmdline_len = 0;
  for(i = 0; i < argc; i++) {
    cmdline_len += strlen(argv[i]) + 1;
  }
  char cmdline[cmdline_len + 1];
  cmdline[0] = '\0';
  for(i = 0; i < argc; i++) {
    strncat(cmdline, argv[i], cmdline_len);
    cmdline_len -= strlen(argv[i]);
    strncat(cmdline, " ", cmdline_len);
    cmdline_len--;
  }

  /* Initialize OML */
  if((ret = omlc_init("/home/ubuntu/soml/example/liboml2/generator", &argc, argv, NULL)) < 0) {
    logerror("Could not initialise OML\n");
    return -1;
  }

  /* Parse command line arguments */
  poptContext optCon = poptGetContext(NULL, argc, argv, options, 0); /* options is defined in /home/ubuntu/soml/example/liboml2/generator_popt.h */
  while ((c = poptGetNextOpt(optCon)) > 0) {}

  /* Initialise measurement points and start OML */
  oml_register_mps(); /* Defined in /home/ubuntu/soml/example/liboml2/generator_oml.h */
  if(omlc_start()) {
    logerror("Could not start OML\n");
    return -1;
  }

  /* Inject some metadata about this application */
  OmlValueU v;
  omlc_zero(v);
  omlc_set_string(v, PACKAGE_NAME);
  omlc_inject_metadata(NULL, "appname", &v, OML_STRING_VALUE, NULL);

  omlc_set_string(v, PACKAGE_VERSION);
  omlc_inject_metadata(NULL, "version", &v, OML_STRING_VALUE, NULL);

  omlc_set_string(v, cmdline);
  omlc_inject_metadata(NULL, "cmdline", &v, OML_STRING_VALUE, NULL);
  omlc_reset_string(v);

  /* Inject measurements */
  run(g_opts, g_oml_mps_/home/ubuntu/soml/example/liboml2/generator); /* Do some work and injections, see above */

  omlc_close();

  return 0;
}

/*
 Local Variables:
 mode: C
 tab-width: 2
 indent-tabs-mode: nil
 End:
 vim: sw=2:sts=2:expandtab
*/
