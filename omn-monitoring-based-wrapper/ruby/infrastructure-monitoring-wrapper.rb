# Copyright (c) 2015, Andisa Dewi, Yahya Al-Hazmi, Technische Universitaet Berlin

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License
#
# This wrapper program gets a list of resources from SQLite database, 
# about which monitoring data are then fetched from the monitoring tool Zabbix, and then
# sent to the semantic OML server following pre-defined, ontology-based schemas of a set of measurement metrics.
#
# This program requires the following libraries that should be installed:
# Zabbix Library for Ruby (use this command to install: gem install zabbixapi)
# SQLite3 Library for Ruby (use this command to install: gem install sqlite3)
# OML Library for Ruby (use this command to install: gem install oml4r)
# => WARNING: 
# => After installing the OML library, go to the directory where the library is installed
# => For example: /var/lib/gems/1.9.1/gems/oml4r-2.10.6/
# => Go to the lib directory and replace the file oml4r.rb with the modified oml4r.rb
# => located in this directory. The file is modified to support semantic data.

# The following files should also to be in the same directory:
# Configuration file (monitoring-config-data.cfg)
# SQLite database (sqliteDB.db)

require "oml4r"
require "zabbixapi"
require 'sqlite3'
require 'date'
require 'time'

#The following was automatically generated by oml2-scaffold V2.12.0pre.79-58cf-dirty
 #for infrastructure-monitoring version 1.0.0.
#-----------------------------------------------------------------------#

class USED_MEMORY_MP < OML4R::MPBase
 name :used_memory
 param :used_memory, {:type => :double, :relation => "{omn-monitoring:Measurement|omn-monitoring:isMeasurementOf|omn-monitoring-metric:UsedMemory}{omn-monitoring-metric:UsedMemory|omn-monitoring:isMeasurementMetricOf|omn-domain-pc:PC}{omn-monitoring-metric:UsedMemory|omn-monitoring-data:hasMeasurementData|omn-monitoring-data:MeasurementData}{omn-monitoring-data:MeasurementData|omn-monitoring-data:hasMeasurementDataValue|%value%}{omn-monitoring-data:MeasurementData|omn-monitoring:hasUnit|omn-monitoring-unit:Byte}{omn-monitoring-unit:Byte|omn-monitoring-unit:hasPrefix|omn-monitoring-unit:giga}"}
 param :timestamp, {:type => :datetime, :relation => "{omn-monitoring-data:MeasurementData|omn-monitoring-data:hasTimestamp|%value%}"}
 param :physicalresource, {:type => :string, :relation => "{omn-domain-pc:PC|rdfs:label|%value%}"}
 param :virtualresource, {:type => :string, :relation => "{omn-domain-pc:VM|rdfs:label|%value%}{omn-domain-pc:VM|omn-lifecycle:childOf|omn-domain-pc:PC}"}
end

class TOTAL_MEMORY_MP < OML4R::MPBase
 name :total_memory
 param :total_memory, {:type => :double, :relation => "{omn-monitoring:Measurement|omn-monitoring:isMeasurementOf|omn-monitoring-metric:TotalMemory}{omn-monitoring-metric:TotalMemory|omn-monitoring:isMeasurementMetricOf|omn-domain-pc:PC}{omn-monitoring-metric:TotalMemory|omn-monitoring-data:hasMeasurementData|omn-monitoring-data:MeasurementData}{omn-monitoring-data:MeasurementData|omn-monitoring-data:hasMeasurementDataValue|%value%}{omn-monitoring-data:MeasurementData|omn-monitoring:hasUnit|omn-monitoring-unit:Byte}{omn-monitoring-unit:Byte|omn-monitoring-unit:hasPrefix|omn-monitoring-unit:giga}"}
 param :timestamp, {:type => :datetime, :relation => "{omn-monitoring-data:MeasurementData|omn-monitoring-data:hasTimestamp|%value%}"}
 param :physicalresource, {:type => :string, :relation => "{omn-domain-pc:PC|rdfs:label|%value%}"}
 param :virtualresource, {:type => :string, :relation => "{omn-domain-pc:VM|rdfs:label|%value%}{omn-domain-pc:VM|omn-lifecycle:childOf|omn-domain-pc:PC}"}
end

class AVAILABLE_MEMORY_MP < OML4R::MPBase
 name :available_memory
 param :available_memory, {:type => :double, :relation => "{omn-monitoring:Measurement|omn-monitoring:isMeasurementOf|omn-monitoring-metric:AvailableMemory}{omn-monitoring-metric:AvailableMemory|omn-monitoring:isMeasurementMetricOf|omn-domain-pc:PC}{omn-monitoring-metric:AvailableMemory|omn-monitoring-data:hasMeasurementData|omn-monitoring-data:MeasurementData}{omn-monitoring-data:MeasurementData|omn-monitoring-data:hasMeasurementDataValue|%value%}{omn-monitoring-data:MeasurementData|omn-monitoring:hasUnit|omn-monitoring-unit:Byte}{omn-monitoring-unit:Byte|omn-monitoring-unit:hasPrefix|omn-monitoring-unit:giga}"}
 param :timestamp, {:type => :datetime, :relation => "{omn-monitoring-data:MeasurementData|omn-monitoring-data:hasTimestamp|%value%}"}
 param :physicalresource, {:type => :string, :relation => "{omn-domain-pc:PC|rdfs:label|%value%}"}
 param :virtualresource, {:type => :string, :relation => "{omn-domain-pc:VM|rdfs:label|%value%}{omn-domain-pc:VM|omn-lifecycle:childOf|omn-domain-pc:PC}"}
end

class USED_BANDWIDTH_MP < OML4R::MPBase
 name :used_bandwidth
 param :used_bandwidth, {:type => :double, :relation => "{omn-monitoring:Measurement|omn-monitoring:isMeasurementOf|omn-monitoring-metric:UsedBandwidth}{omn-monitoring-metric:UsedBandwidth|omn-monitoring:isMeasurementMetricOf|omn-domain-pc:PC}{omn-monitoring-metric:UsedBandwidth|omn-monitoring-data:hasMeasurementData|omn-monitoring-data:MeasurementData}{omn-monitoring-data:MeasurementData|omn-monitoring-data:hasMeasurementDataValue|%value%}{omn-monitoring-data:MeasurementData|omn-monitoring:hasUnit|omn-monitoring-unit:bitpersecond}{omn-monitoring-unit:bitpersecond|omn-monitoring-unit:hasPrefix|omn-monitoring-unit:mega}"}
 param :timestamp, {:type => :datetime, :relation => "{omn-monitoring-data:MeasurementData|omn-monitoring-data:hasTimestamp|%value%}"}
 param :physicalresource, {:type => :string, :relation => "{omn-domain-pc:PC|rdfs:label|%value%}"}
 param :virtualresource, {:type => :string, :relation => "{omn-domain-pc:VM|rdfs:label|%value%}{omn-domain-pc:VM|omn-lifecycle:childOf|omn-domain-pc:PC}"}
end

class AVAILABILITY_MP < OML4R::MPBase
 name :availability
 param :availability, {:type => :double, :relation => "{omn-monitoring:Measurement|omn-monitoring:isMeasurementOf|omn-monitoring-metric:Availability}{omn-monitoring-metric:Availability|omn-monitoring:isMeasurementMetricOf|omn-domain-pc:PC}{omn-monitoring-metric:Availability|omn-monitoring-data:hasMeasurementData|omn-monitoring-data:MeasurementData}{omn-monitoring-data:MeasurementData|omn-monitoring-data:hasMeasurementDataValue|%value%}"}
 param :timestamp, {:type => :datetime, :relation => "{omn-monitoring-data:MeasurementData|omn-monitoring-data:hasTimestamp|%value%}"}
 param :physicalresource, {:type => :string, :relation => "{omn-domain-pc:PC|rdfs:label|%value%}"}
 param :virtualresource, {:type => :string, :relation => "{omn-domain-pc:VM|rdfs:label|%value%}{omn-domain-pc:VM|omn-lifecycle:childOf|omn-domain-pc:PC}"}
end

#-----------------------------------------------------------------------#

#write code here
def get_vars(conf_file)
		#Here we define a couple of things
		#First is the regular expression that we use to 
		#get rid of whitespace and the array characters.
		line_sub = Regexp.new(/\s+|\\|"|\[|\]/)

		temp = Array.new
		vars=Hash.new

		#Check and make sure that the file exists
		unless File.exists?(conf_file) then
		  raise "The specified configuration file doesn't exist!"	
		end
		IO.foreach(conf_file) do |line|
			#discard comment lines
			if line.match(/^#/)
				next
			elsif
				#discard a blank line
				line.match(/^$/)
				next
			else
				#Snag variable and throw it into the varhash
				temp[0],temp[1] = line.to_s.scan(/^.*$/).to_s.split('=')

				#Match our regular expression and substitute
				temp.collect! do |val|
					val.gsub(line_sub, "")
				end
				#Add the variables to our hash
				vars[temp[0]] = temp[1]
			end
		end
		#And return them
		return vars
	end

conf = get_vars("./monitoring-config-data.cfg")

oml_opts = {
  :appName => conf['appname'],
  :domain => conf['domain'],
  :nodeID => conf['sender'],
  :collect => conf['target']
}

zabbix_opts = {
  :url => conf['zabbixuri'] + '/api_jsonrpc.php',
  :user => conf['username'],
  :password => conf['password']
}

OML4R::init(ARGV, oml_opts)

zbx = ZabbixApi.connect(zabbix_opts)

begin
    
    db = SQLite3::Database.open "sqliteDB.db"
    stm = db.prepare "select distinct(host_name), collector_uri, vm_uri from virtual_physical_map"
    rs = stm.execute

    rs.each do |row|
    	host = zbx.query(
		  :method => "host.get",
		  :params => {
		    :output => "extend",
		    :search => {
		      :name => row[0]
		    }
		  }
		)
		unless host.empty?
			hostid = host[0]["hostid"]
		end

    	total_memory = zbx.query(
		  :method => "item.get",
		  :params => {
		    :output => "extend",
		    :hostids => hostid, 
		    :search => {
		      :name => "Total memory"
		    }
		  }
		)
		unless total_memory.empty?
		  total_memory_ts = total_memory[0]["lastclock"].to_i
		  total_memory = total_memory[0]["lastvalue"].to_f / (1024)**3
		  TOTAL_MEMORY_MP.inject(total_memory, Time.at(total_memory_ts).localtime.strftime("%Y-%m-%dT%H:%M:%S"), row[0], row[2])
		end

		used_memory = zbx.query(
		  :method => "item.get",
		  :params => {
		    :output => "extend",
		    :hostids => hostid, 
		    :search => {
		      :name => "Used memory"
		    }
		  }
		)
		unless used_memory.empty?
		  used_memory_ts = used_memory[0]["lastclock"].to_i
		  used_memory = used_memory[0]["lastvalue"].to_f / (1024)**3
		  USED_MEMORY_MP.inject(used_memory, Time.at(used_memory_ts).localtime.strftime("%Y-%m-%dT%H:%M:%S"), row[0], row[2])
		end

		available_memory = zbx.query(
		  :method => "item.get",
		  :params => {
		    :output => "extend",
		    :hostids => hostid, 
		    :search => {
		      :name => "Available memory"
		    }
		  }
		)
		unless available_memory.empty?
		  available_memory_ts = available_memory[0]["lastclock"].to_i
		  available_memory = available_memory[0]["lastvalue"].to_f / (1024)**3
		  AVAILABLE_MEMORY_MP.inject(available_memory, Time.at(available_memory_ts).localtime.strftime("%Y-%m-%dT%H:%M:%S"), row[0], row[2])
		end

		used_bandwidth = zbx.query(
		  :method => "item.get",
		  :params => {
		    :output => "extend",
		    :hostids => hostid, 
		    :search => {
		      :key_ => "net.if.in[eth2]"
		    }
		  }
		)
		unless used_bandwidth.empty?
		  used_bandwidth_ts = used_bandwidth[0]["lastclock"].to_i
		  used_bandwidth = used_bandwidth[0]["lastvalue"].to_f / (1024)**2
		  USED_BANDWIDTH_MP.inject(used_bandwidth, Time.at(used_bandwidth_ts).localtime.strftime("%Y-%m-%dT%H:%M:%S"), row[0], row[2])
		end

    end
    
rescue SQLite3::Exception => e 
    
    puts "Exception occurred"
    puts e
    
end

OML4R::close()

		  



